/*******************************************************************************
 *  cnvsth2seg.c		
 *  Copyright 2013 Westheimer Energy Consultants Ltd ALL RIGHTS RESERVED
 ******************************************************************************/

/* This file last updated 20130916:1150 */

/*
 *  This program reads three streams of input, and constructs several streams
 *  of output. The three input streams are all extracted from the STH database,
 *  and are (1) the File Header information, (2) the Trace Header information -
 *  with all trace headers consecutive, and (3) the Trace Data information, with
 *  all the trace data consecutive. We do not have to consider the original
 *  chunking of the data, as created by program seg2sth, as all the data chunks
 *  will have been concatenated by the database extract process.
 *  The output files are SEG-Y files, each containing one time-slice from the
 *  trace data. each output SEG-Y file consists of (1) the File Header inform-
 *  ation (the same for all files), (2) a series of alternately (a) a Trace 
 *  Header record, and (b) a Trace Data record containing the relevant Trace
 *  Data samples. There are *four* different possible patterns of output:
 *  a) No Split: all the incoming Trace Data is produced in a single output
 *     file;
 *  b) Inline Split: there are a series of output files, each containing the
 *     data for one, and only one, INline;
 *  c) Crossline Split: there are a series of output files, each containing the
 *     data for one, and only one, CROSSline;
 *  d) Timeline Split: there are a series of output files - the number of files
 *     is limited by the number of files which can simultaneously be open, and
 *     by the number of samples presented per input point. Each output file
 *     contains the data for one, and only one, timeslice.
 *  The names of the output SEG-Y files are constructed from:
 *  (1) the given directory name (if any), and
 *  (2) the given file-name base, and 
 *  (3) if there is a split, then 
 *      (a) an underscore-letter-underscore, indicating the type of split 
 *          (_I_, _X_, _T_), and 
 *      (b) a number indicating the inline number (for _I_), or the crossline 
 *          number (for _X_), or the vertical sequence number (for _T_) of the 
 *          data in that output slice.
 *
 *  Version 0.52 (upwards): change of file-naming convention:
 *             <survey-name>/iline/I<number>
 *             <survey-name>/xline/X<number>
 *             <survey-name>/tline/T<number>
 *
 *  Each Trace Header record, as received by this program, contains a count of
 *  the number of samples in the Trace Data for that point. For Time-Sliced this 
 *  count is *not* necessarily the original value in the Trace Header records 
 *  (as archived), but may have been constructed by the database retrieve 
 *  process. The value in this field, in the first Trace Header record read, is 
 *  used, for timesliced data, to determine how many output files this program 
 *  will generate. If that value is n then the number of SEG-Y files generated 
 *  by this program is at most n - each containing (a) a copy of the (one and 
 *  only) file header, (b) every Trace Header record, and (c) interleaved 
 *  between the Trace Header records a Trace Data record containing a single 
 *  value. The File Header information is read only once, and held, by this 
 *  program, in memory.
 *
 *  The Trace Header records generated by this program may be altered by this
 *  program, and are *not* necessarily a simple copy of the input. The only 
 *  alteration made (Version 0.51) is to indicate the number of samples in the 
 *  output record as being 1.
 *
 *  There are four different actions we may want this program to perform:
 *
 *  1) Take the three input files and create just one SEG-Y file as output. This
 *     is the same as program cnvsth2seg;
 *
 *  2) Take the three input files, and generate a series of SEG-Y files, each
 *     referring to one, and only one, inline. To do this we have to know the
 *     location of the 'inline' field in the Trace Header record. As the files
 *     are read, when the 'inline' value in the Trace Header drops down, we know
 *     that we have read all the crosslines for the previous inline, and we can  
 *     start the next output file;
 *
 *  3) Take the three input files, and generate a series of SEG-Y files, each
 *     referring to one, and only one, crossline. To do this we have to know the
 *     location of the 'crossline' field in the Trace Header record. As the 
 *     files are read, when the 'crossline' value in the Trace Header drops
 *     down, we know that we have read all the inlines for the previous cross-
 *     line, and we can start the next output file;
 *
 *  4) Take the three input files, and create a series of SEG-Y files (as des-
 *     cribed in the long description earlier), each containing only one data
 *     value for each Trace Header record. As each Trace Data record is read, it
 *     is used to add just one more data value to each of the Seg-Y files being
 *     generated. Note that we have a limit of the number of SEG-Y files that we
 *     can generate at one time, and hence a limit of the number of data values
 *     that can be passed in, for any given point, in one call of this program.
 *     TO DO: It would be possible to extend this program so that there is no
 *     limit to the number of data values that can be passed in, but the program 
 *     could process as many data values as possible (the first tranche), and
 *     then rewind the data file, and process the next tranche, and so on.
 *     similarly, this program could be altered to process just certain spec-
 *     ified data items from the range of data items presented, at any one call.
 *
 *  There are a number of possible parameters that can be passed to this
 *  program, to indicate its input and output file(s), and which time slice(s)
 *  are to be generated.
 *
 *  Option -o is mandatory; either -i must be specified or all of -f -t -d:
 *  -i <filename>  the root of the three filenames, which will be constructed
 *                 as <filename>.ofh and <filename>.oth and <filename>.otd
 *  -o <filename>  the root (base) name of the output files
 *  -f <filename>  file to be used, in lieu of the .ofh file indicated by -i
 *  -t <filename>  file to be used, in lieu of the .oth file indicated by -i
 *  -d <filename>  file to be used, in lieu of the .otd file indicated by -i
 *
 *  Options -n -B -S are optional, and may be deduced from the input files. If
 *  either of options -B or -S are specified, then they are used in generating
 *  the output file names:
 *  -n <number>    Number of output files to generate (default 1, maximum 10)
 *  -B <number>    Subscript of first time-slice data to generate (default 0)
 *  -S <number>    Step-size for subsequent time-slice data (default 1)
 *
 *  Options -X and -I allow the displacements of the INline and CROSSline fields
 *  in the incoming Trace Data records to be specified:
 *  -I <number>    Displacement of INline field in Trace Data - Default 188
 *  -X <number>    Displacement of CROSSline field in Trace Data - Default 192
 *
 *  Option -R indicates whether this program is permitted to overwrite existing
 *  files or not. The default is that existing files will be overwritten with
 *  no comment:
 *  -R <Yes/No>    YES: permit overwrite; NO: do not permit overwrite (default)
 *
 *  Option -u is the default; options -l and -L ARE WITHDRAWN:
 *  -u             Use data lengths only from the TH header records
 /  -L             Data length determined from leading word in TD itself (Dflt.)
 /  -l             Data length determined from FH and TH header records
 *
 *  Options -c -b ARE NO LONGER USED, as the incoming data will already have
 *  been dechunked:
 /  -c <YES/NO>    Dechunk the incoming data - default is YES (also -b)
 *
 *  Options -C -k -K ARE WITHDRAWN:
 /  -C <0/2/4/64>  Insert extra count preceding output LOB
 /  -k <YES/NO>    Remove/do not remove K null characters at start of chunk
 /  -K <number>    Number of characters to remove from start of chunk - dflt. 0
 *
 *  Options -E -O are available, but pre-EAGE (June 2013) not used:
 *  -E <i/e>       Floating-point type of input data (default 'i'=IBM)
 *  -O <i/e>       Floating-point type of output data (default 'e'=IEEE)
 *
 *  Options -1 -2 -3 are temporarily (Version 0.1) WITHDRAWN:
 *  -1             All input is in a single file
 *  -2             Input is in two files: File Header, and TH+TD
 *  -3             (Default) Input is in three files
 *
 *  -v             Show version number of this program
 *
 *  -s             TESTING: data reading is skipped
 *  -T <trace>     TESTING: for debug use only, set trace flag(s)
 *
 */

/*
 * Version history:
 *
 *   0.50          First beta release
 *
 *   0.53          Change of output file naming convention to subdirectories
 *                 Verify generated filenames are within numeric range
 *                 Implement -R parameter to test overwriting permission
 *
 *   0.56/0.57     a) only filenames, not directories
 *                 b) .sgy added to filenames
 *                 c) correction of big/little-endian bug in filename building
 *                 d) correct splitting of Timeslice output
 */

/*
 *  TO DO:
 *                 Ensure comments in this code are complete
 *                 Tighten performance to ensure fast running
 *                 Verify size limits within this code
 *        
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>       /* for getopts()   */
#include <sys/types.h>
#include <sys/stat.h>   
#include <stdint.h>
#include <fcntl.h>
#include <math.h>         /* for sqrt()      */

#include "cnvswap.h"
#include "cnvendian.h"
#include "cnvfloat.h"
#include "cnvsegyfmt.h"
#include "cnvsth2seg.h"

#define DEBUG_LEV 0

#define NEVERSWAP 0

int main (int argc, char * argv[]) 
{
    /*
     *  External routines for handling input parameters:
     */
    extern char *optarg;
    extern int optind, optopt;
    
    /*
     *   Three files are declared, each with a pointer to the command line
     *   parameter, and the FILE pointer, and the saved (or constructed)
     *   file name:
     */
    char *ifhfile = (char *)NULL;    /* File Header Input file name     */
    FILE *fhipf   = (FILE *)NULL;    /* The File Header input file      */
	char fhnamein   [NAMELEN+1];     /* Name of File Header input file  */
    char *ithfile = (char *)NULL;    /* Trace Header Input file name    */
    FILE *thipf   = (FILE *)NULL;    /* The Trace Header input file     */
	char thnamein   [NAMELEN+1];     /* Name of Trace Header input file */
    char *itdfile = (char *)NULL;    /* Trace Data Input file name      */
    FILE *tdipf   = (FILE *)NULL;    /* The Trace Data input file       */
	char tdnamein   [NAMELEN+1];     /* Name of Trace Data input file   */
    char *odirname = (char *)NULL;   /* Name of output directory, if any*/
    char *ofile   = (char *)NULL;    /* Output SEG file name base       */
    FILE *opf[MAXOUTFILES];          /* The Output SEG file pointers    */
	char fnameout   [NAMELEN+1];     /* Name base of Output SEG file    */
    char fnameoutD  [MAXOUTFILES][NAMELEN+1]; /* All Output SEG filenames */
    char alldirname [NAMELEN+1];     /* Output directory name, if any   */
    char *oformat =   (char *)NULL;  /* Output floating-point format    */
    int  input_endian  = BIG;        /* Default endian-ness of input    */
    int  output_endian = BIG;        /* Default endian-ness of output   */
    char *pin_end =   (char *)NULL;  /* Pointer to param. for in_endian */
    char *pout_end =  (char *)NULL;  /* Pointer to param. for out_endian*/

    char *nstr     =  (char *)NULL;  /* -n parameter value              */
    char *Fstr     =  (char *)NULL;  /* -F parameter value              */
    char *Sstr     =  (char *)NULL;  /* -S parameter value              */
    char *tstring  =  (char *)NULL;  /* Pointer to work string          */
    char *slicetype = (char *)NULL;  /* -P parameter value              */
    char *Istr     =  (char *)NULL;  /* -I parameter value              */
    char *Xstr     =  (char *)NULL;  /* -X parameter value              */
    char *rewrite  =  (char *)NULL;  /* -R parameter value              */
    int   noutputfiles = MAXOUTFILES;/* Number of output files to generate    */
    int   firstsample = 0;           /* Displacement of first data sample     */
    int   samplestep = 1;            /* Step size in units between samples    */
//    int   TH_ONE = 1;                /* Big-endian value one for TH o/p */
    int   fnameD[MAXOUTFILES];       /* Detailed otput file name suffix values*/
    int   sliceform = 0;             /* Type of slicing to be done (if any)  */
    
    
    char  c;                         /* Work variable for parameter unpacking */
    char  cc;                        /* Work variable for character holding   */
    char  work16[16];                /* Work array - temporary strings        */
    int   w4;
    char  *pw4 = (char *)&w4;
    int   thisendian  = LITTLE;      /* Default Endianicty of *this* machine  */
    int   cmderr = 0;                /* Command error indicator - default OK  */
    int   i, j, k, l;                /* Work variables                        */
    unsigned short m, n;             /* Work variables                        */
    short int sn;                    /* Work variable                         */
    int   tprint = 0;                /* Debug trace indicator - default none  */
    int   TraceEnd = 0;              /* Indicate end of Trace Header input    */
    int   TraceCount = 0;            /* Count of Trace (and data) records read*/
    int   FHlength1 = LEN_FH;        /* Length of a singe File Header         */
    int   FHlength = 0;              /* Length of File Header written         */
    int   THlength1 = LEN_TH;        /* Length of a single Trace Header       */
    int   THlength = 0;              /* Total length of all Trace Headers out */
    int   TDlength = 0;              /* Total length of all data written      */
    int   iFHlength = 0;             /* Length of File Header read            */
    int   iTHlength = 0;             /* Total length of all Trace Headers IN  */
    int   iTDlength = 0;             /* Total length of all data read         */
    int   CountFilesIn = 3;          /* Number of input files expected 1/2/3  */ 
    int   ExtraTH = 0;               /* Extra bytes in TH record above LEN_TH */
    int   ThisCross = 0;             /* Crossline number for this line        */
    int   ThisIn = 0;                /* Inline number for this line           */
    int   PrevCross = -1;            /* Crossline number for previous line    */
    int   PrevIn = -1;               /* Inline number for previous line       */
    int   ThisTime = 0;              /* Timeline number for this line         */
    int   PrevTime = -1;             /* Timeline number for previous line     */
    int   disp_inline = 188;         /* Default displacement INline in TH     */
    int   disp_crossline = 192;      /* Defaule displacement CROSSline in TH  */
    int   len_inline = 4;            /* Length of INline field, in bytes      */
    int   len_crossline = 4;         /* Length of CROSSline field, in bytes   */
    unsigned short nauxfh = 0;       /* Number of Auxiliary File Headers      */
    unsigned short nsamplesFH = 0;   /* Number of samples, from File Header   */
    unsigned short nsamplesTH = 0;   /* Number of samples, from Trace Header  */
    int   usensamplesTH = 0;         /* nsamplesTH correct for program limits */
    unsigned short TDDataLength = 0; /* Record length field from input TD     */
    short UseFHsamp = 0;             /* If nonzero, use nsamplesFH            */
    short UseTHsamp = 0;             /* If nonzero, use nsamplesTH            */
    short nonulls = 0;               /* If nonzero, kill leading nulls in brk */
    int   WriteTwo = 0;              /* If nonzero, put two-byte count on LOB */
    int   WriteFour = 0;             /* If nonzero, put 2+2 byte count on LOB */
    int   Write64 = 0;               /* If nonzero, put 64-bit count on LOB   */
    int   nsamples = 0;              /* Consolidated number of samples to use */
    int   sampthisset = 0;           /* No. of samples wanted from this set   */
    int   datatype = 0;              /* Data type as recorded in file header  */
    int   skiplength = 2;            /* Amount of chunk to skip, pre samples  */
    int   chunkstart = 1;            /* If nonzero we are at first chunk      */
    int   THfilecount = -1;          /* File count value to insert in TH      */
    int   THsegcount = -1;           /* SEGY counter to insert in TH          */
    int   THfcUSE = -1;              /* Usable (unswapped) version THfilecount*/
    int   THscUSE = -1;              /* Usable (unswapped) version THsegycount*/
    int   ReadLength = 0;            /* Size of data record to read, in bytes */
    int   WriteLength = 0;           /* Size of data record to write, bytes   */
    int   rew = 0;                   /* Do (0) / Do not (1) allow overwrite   */ 
    int   SafeTime = 0;              /* If nonzero, do not check time range   */
    int   SafeCross = 0;             /* If nonzero, do not check cross range  */
    int   SafeIn = 0;                /* If nonzero, do not check inine range  */
    int   SkipReadData = 0;          /* Debug trace - skip reading TD data    */
    int   TotalSamples = 0;          /* Debug trace - total number of samples */
    int   TotalSamplesFH = 0;        /* Debug trace - samples as per FH rec.  */
    int   TotalSamplesTH = 0;        /* Debug trace - samples as per TH recs. */
    int   FileNameMax = 16;          /* Length of Filename (?) prefix in chunk*/
    int   LOBlength = 0;             /* Computer length of LOB                */
    int   NeverSwap = NEVERSWAP;     /* Never endian swap if this is nonzero  */
    short LOBlength2 = 0;            /* Two-byte version of LOBlength         */
    short floatconvert = NOCONVERT;  /* Floating point conversion flag        */
    char  cLOBlength4[4];            /* Splittable version of (2+2) LOB count */
//    long int LOBlength64 = 0;        /* 64-bit version of LOBlength           */
    char  FmtRevNo[2];               /* Format Revision Number of SEGY input  */
    
    /*
     * NOTE: the first element (subscript 0) of the typelens array is for
     *       type 1, the second element (subscript 1) for type 2, and so on
     */
    int   typelens[MAXTYPE] = {4, 4, 2, 4, 4, 4, 4, 1 };
    int   typelength = 0;
    short typelenwk = 0;
    
	char  progname [4096];           /* Name of *this* program                */
	
	char slash = '/';
    //	char dot   = '.';
    
    char FHtype[] = ".ofh";          /* File type for File Header file        */
    char THtype[] = ".oth";          /* File type for Trace Header file       */
    char TDtype[] = ".otd";          /* File type for Trace Data file         */
	
    unsigned char FHrec[LEN_FH+16+1];/* File header record, read in           */
    unsigned char THrec[LEN_TH+16+1];/* Trace header record, read in          */
    
    char temp[4096];                 /* Work area */
    unsigned char DataBuffer[4*MAXBUFFER+1];
    /*
	 *  Set to default debug level:
	 */
	tprint = DEBUG_LEV;
	
    /*  COPYRIGHT  */
    fprintf(stderr, "This program is strictly Copyright (c) 2013 Westheimer "
            "Energy Consultants Inc.\n"
            "All rights reserved\n\n");
    
    /*  ENDIANNESS  */
    
	/*
	 *  Test and remember the endianness of *this* machine:
	 */
	if (ENDIANNESS == BIG)
	{
		thisendian = BIG;
        fprintf(stderr, "INFO: This machine is BIG-endian.\n");
	}
	else if (ENDIANNESS == LITTLE)
	{
		thisendian = LITTLE;
        fprintf(stderr, "INFO: This machine is LITTLE-endian.\n");
	}
	else 
	{
		fprintf(stderr,
                "ERROR: ENDIAN format of this machine not supported (%d / %x).\n",
                endianness,endianness);
		fprintf(stderr, "[endianness first byte is %x]\n",
                *(const char *)&endianness);
		cmderr++;
	}
    
    /*
     *  If the endianness of this machine is LITTLE then correct the TH_ONE to
     *  contain a big-endian value one:
     */
//    if (ENDIANNESS == LITTLE)
//    {
//        TH_ONE = swap_int32(TH_ONE);
//    }
	
    /*  Output file pointers to NULL as initial values: */
    for (i=0; (i<MAXOUTFILES); i++)
    {
        opf[i] = (FILE *)NULL;
        fnameD[i] = -1;
    }
    
    /*  Output directory name is empty, by default: */
    alldirname[0] = '\0';
    
    /*  PROGRAM NAME  */
    
	/*
	 *  Remember the program name - the name of this program - for
	 *  debug and message printout. We edit out, from the name of
	 *  the program as invoked, any prior directory name specified:
	 */
	strcpy(temp, argv[0]);
	j = strlen(temp); 
	i = 0;
	while((j>i) && (temp[j] != slash)) 
	{
		j--;
	}
	/* If there actually was a slash in the program name, we are now pointing at
	 * it - so move forwards to point to the first character after the
	 * rightmost slash: */
	if ( temp[j] == slash ) 
	{
		j++;
	}
	k = strlen(temp); 
	strncpy(progname, &temp[j], k-j);
	/* Add a terminating string end character: */
	progname[k-j] = '\0';
	
    
    /*  COMMAND LINE PROCESSING  */
    
	/*
     *  Read in and initially process each command line parameter:
     */
    
    UseFHsamp = 0;
    UseTHsamp = 0;
    
    while ((c = getopt(argc, argv, ":n:P:B:S:E:I:X:h:r:i:o:f:t:d:D:T:F:e:O:R:lAGCvus")) != -1)
    {
        switch(c)
        {
            /* Use FH sample count throughout: */
            case 'l':
                UseFHsamp = 1;
                break;
                
            /* Unsafe - do not test inline range: */
            case 'A':
                SafeIn = 1;
                break;
                
            /* Unsafe - do not test crossline range: */
            case 'G':
                SafeCross = 1;
                break;
                
            /* Unsafe - do not test timeline range: */
            case 'C':
                SafeTime = 1;
                break;
                
            /* Number of output files: */
            case 'n':
                nstr = optarg;
                i = atoi(nstr);
                noutputfiles = i;
                if ((i<1) || (i>MAXOUTFILES))
                {
                    fprintf(stderr, 
                            "Error: -n must be between 1 and %d, not %d\n",
                            MAXOUTFILES, i);
                    cmderr++;
                }
                break;
                
            /* Type of slicing - if any - being done by this program */
            case 'P':
                slicetype = optarg;
                /*
                 *  Verify that the type of slicing is one of t/T i/I x/X n/N
                 */
                if ((strncmp(slicetype, "x", 1)==0) || 
                    (strncmp(slicetype, "X", 1)==0))
                {
                    fprintf(stderr, "INFO:  Crossline sample extraction\n");
                    sliceform = 1;
                    noutputfiles = 1;
                }
                else if ((strncmp(slicetype, "i", 1)==0) || 
                         (strncmp(slicetype, "I", 1)==0))
                {
                    fprintf(stderr, "INFO:  Inline sample extraction\n");
                    sliceform = 2;
                    noutputfiles = 1;
                }
                else if ((strncmp(slicetype, "t", 1)==0) || 
                         (strncmp(slicetype, "T", 1)==0))
                {
                    fprintf(stderr, "INFO:  Timeline sample extraction\n");
                    sliceform = 3;
                    /*
                     *  Note that 'noutputfiles' is NOT altered here, as this
                     *  is the case when many output files may be generated at
                     *  the same time.
                     */
                }
                else if ((strncmp(slicetype, "n", 1)==0) || 
                         (strncmp(slicetype, "N", 1)==0))
                {
                    fprintf(stderr, 
                            "INFO:  No sub-extraction: all samples used\n");
                    sliceform = 0;
                    noutputfiles = 1;
                }
                else 
                {
                    fprintf(stderr, 
                            "ERROR: Invalid -P option [%s] - only x,i,t,n permitted\n", 
                            slicetype);
                    fprintf(stderr, "       Program terminates.\n");
                    exit (BAD_P_PARAM);
                }
                break;
                
            /* Displacement of INline in THrec: */
            case 'I':
                Istr = optarg;
                /* The -I parameter is as Column Number - subtract one to get
                 * the Displacement:
                 */
                disp_inline = atoi(Istr) - 1;
                if ((disp_inline<0) || (disp_inline>LEN_TH))
                {
                    fprintf(stderr,"ERROR: -I must be between 1 and %d, not %d\n",
                            LEN_TH, disp_inline+1);
                    cmderr++;
                }
                break;
                
            /* Displacement of CROSSline in THrec: */
            case 'X':
                Xstr = optarg;
                /* The -X parameter is as Column Number - subtract one to get
                 * the Displacement:
                 */
                disp_crossline = atoi(Xstr) - 1;
                if ((disp_crossline<0) || (disp_crossline>LEN_TH))
                {
                    fprintf(stderr,"ERROR: -X must be between 1 and %d, not %d\n",
                            LEN_TH, disp_crossline+1);
                    cmderr++;
                }
                break;
                
            /* Displacement of first sample to use: */
            case 'B':
                Fstr = optarg;
                i = atoi(Fstr);
                if ((i<0) || (i>MAXSAMPLES))
                {
                    fprintf(stderr, 
                            "ERROR: -B must be between 1 and %d, not %d\n",
                            MAXSAMPLES, i);
                    cmderr++;
                }
                else 
                {
                    firstsample = i;
                }
                break;
                
            /* Step-size between samples to use: */
            case 'S':
                Sstr = optarg;
                i = atoi(Sstr);
                /*  Do not check for an upper bound on this value - but DO
                 *  check against zero (special case), and negative (bad):
                 */
                if (i == 0)
                {
                    i = 1;
                    fprintf(stderr, 
                            "INFO:  -S 0 indicates no incrementation - OK\n");
                }
                else if (i<0)
                {
                    fprintf(stderr, 
                            "ERROR: -S may not be negative %d\n",i);
                    cmderr++;
                }
                samplestep = i;
                break;
                
            /* Input file name root: */
            case 'i':
				ifhfile = optarg;
                ithfile = ifhfile;
                itdfile = ifhfile;
                strcpy(fhnamein, ifhfile);
                /*
                 *  When specifying -i we can set all three input file names
                 *  from the -i root. This means that we have to append the
                 *  fixed file types to the root name give by the user here:
                 */
                strcpy(thnamein, ifhfile);
                strcpy(tdnamein, ifhfile);
				strcat(fhnamein, FHtype);
                strcat(thnamein, THtype);
                strcat(tdnamein, TDtype);
                break;
                
            /* Output file name root: */
            case 'o':
				ofile = optarg;
				strcpy(fnameout, ofile);
                break;
                
            /* Input file name, for file header file only: */
            case 'f':
				ifhfile = optarg;
				strcpy(fhnamein, ifhfile);
                break;
                
            /* Input file name, for trace header file only: */
            case 't':
				ithfile = optarg;
				strcpy(thnamein, ithfile);
                break;
                
            /* Input file name, for trace data only: */
            case 'd':
				itdfile = optarg;
				strcpy(tdnamein, itdfile);
                break;
                
            /* Output directory: */
            case 'D':
                odirname = optarg;
                strcpy(alldirname, odirname);
                break;
                
            /* Trace Header sequence number in line: */
            case 'h':
                THfilecount = atoi(optarg);
                fprintf(stderr, "TH Trace seq. no. in line is: %d\n",
                        THfilecount);
                THfcUSE = THfilecount;
                if (thisendian != input_endian)
                {
                    THfilecount = swap_int32(THfilecount);
                }
                break;
                
            /* Trace Header sequence number in file initial value: */
            case 'r':
                THsegcount = atoi(optarg);
                THscUSE = THsegcount;
                fprintf(stderr, "TH Trace seq. no. in file starts at: %d\n",
                        THsegcount);
                if (thisendian != input_endian)
                {
                    THsegcount = swap_int32(THsegcount);
                }
                if (THsegcount == 0)
                {
                    fprintf(stderr, "ERROR: -r field may not be zero\n");
                    cmderr++;
                }
                break;
                
            /* DEBUG: skip some of the Trace Header metadata output: */
            case 'e':
                ExtraTH = atoi(optarg);
                break;
                
            /* TESTING: set debug trace flags: */
            case 'T':
                tprint = atoi(optarg);
                fprintf(stderr,
                        "WARNING: trace flags (-T) not for production\n");
                break;
                
            /* Show program version number and compile date: */
            case 'v':
                fprintf(stderr, "Program Version %s %s\n", STHVERSION, STHDATE);
				fprintf(stderr, "Program Name:   %s : %s\n", progname, argv[0]);
                break;
                
            /* Use sample count as stated in Trace Header record: */
            case 'u':
                UseTHsamp = 1;
                break;
                
            /* Floating-point format of the output: */
            case 'F':
                oformat = optarg;
                break;
                
            /* TESTING only: skip data reading: */
            case 's':
                SkipReadData = 1;
                fprintf(stderr,
                        "WARNING: Data reading is skipped - not for production\n");
                break;
                
            /* Set endian value of the input data */
            case 'E':
                pin_end = optarg;
                if (NeverSwap != 0)
                {
                    fprintf(stderr, 
                            "Warning: -E option ignored - not yet supported\n");
                }
                break;
                
            /* Set endian value of the output data: */
            case 'O':
                pout_end = optarg;
                if (NeverSwap != 0)
                {
                    fprintf(stderr, 
                            "Warning: -O option ignored - not yet supported\n");
                }
                break;
                
            /* Rewrite (i.e. permit overwrite) of output files: */
            case 'R':
                rewrite = optarg;
                /* Check argument against y/Y/n/N */
                if ((strncmp(rewrite,"n",1)==0)||(strncmp(rewrite, "N", 1)==0))
                {
                    fprintf(stderr, "INFO: Existing files may NOT be overwritten\n");
                    rew = 0;
                }
                else if ((strncmp(rewrite,"n",1)==0)||(strncmp(rewrite, "N", 1)==0))
                {
                    fprintf(stderr, "INFO: Existing files CAN be overwritten\n");
                    rew = 1;
                }
                else 
                {
                    fprintf(stderr, "ERROR: -R may be Y or N not %s\n",rewrite);
                    cmderr++;
                }

                break;
                
            /* Unrecognised option: */
            case '?':
				fprintf(stderr, "ERROR: Unrecognized option: -%c\n", optopt);
				cmderr++;
                
        }
    }
    
    
    /*  VERIFY INPUT AND OUTPUT FILES  */
    
    /*
     *  Check that we have an output file, and that it can be opened:
     *  If there is no slicing taking place, then there must be a -o value
     *  If there is slicing, then we CAN have a null -o
     */
    if ((ofile == (char *)NULL) && (sliceform == 0))
    {
        fprintf(stderr, "ERROR: No output file base (-o) has been specified\n");
        cmderr++;
    }
    else 
    {
        fprintf(stderr, "Information: output file name base is %s%s\n", 
                odirname, ofile);   
    }
    
    /*
     *  Check that we have the right number of openable input files.
     */
    if (CountFilesIn == 1)
    {
        ithfile = ifhfile;
        itdfile = ifhfile;
    }
    else if (CountFilesIn == 2)
    {
        ithfile = ifhfile;
    }
    
    /*
     *  First, we check that we have at least the File Header file information,
     *  because if that does not exist then all of the run is pointless.
     *  We then check whether both of the other two files have been 
     *  specified.
     */
    if (ifhfile == (char *)NULL)
    {
        fprintf(stderr, 
                "ERROR: No input File Header file (-i or -f) specified\n");
        cmderr++;
    }
    else
    {
        /*
         *  Try to open the input File Header file:
         */
        if (tprint !=0 ) fprintf(stderr, "Opening Input File Header [%s]\n", 
                                 fhnamein);
        fhipf = fopen(fhnamein,"r");
        if (fhipf == (FILE *)NULL)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open input File Header (-i -f)  [%s]\n"
                    "       errno = %d\n", fhnamein, errno);
            cmderr++;
        }
        /* Leave the input File Header file open for the run */        
    }
    
    if (ithfile == (char *)NULL)
    {
        fprintf(stderr, 
                "ERROR: No input Trace Header file (-i or -t) specified\n");
        cmderr++;
    }
    else 
    {
        /*
         *  Try to open the input Trace Header file:
         */
        if (tprint !=0 ) fprintf(stderr, "Opening Input Trace Header [%s]\n", 
                                 thnamein);
        thipf = fopen(thnamein, "r");
        if (thipf == (FILE *)NULL)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open input Trace Header (-i -t) [%s]\n"
                    "       errno = %d\n", thnamein, errno);
            cmderr++;
        }
        /* Leave the input Trace Header file open for the run */        
    }
    
    if (itdfile == (char *)NULL)
    {
        fprintf(stderr, 
                "ERROR: No input Trace Data file (-i or -d) specified\n");
        cmderr++;
    }
    else 
    {
        /*
         *  Try to open the input Trace Data file:
         */
        if (tprint !=0 ) fprintf(stderr, "Opening Input Trace Data [%s]\n", 
                                 tdnamein);
        tdipf = fopen(tdnamein, "r");
        if (tdipf == (FILE *)NULL)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open input Trace Data (-i -d)   [%s]\n"
                    "       errno = %d\n", tdnamein, errno);
            cmderr++;
        }
        /* Leave the input Trace Data file open for the run */        
    }
       
    
    if (oformat != (char *)NULL)
    {
        if ((*oformat == 'i') || (*oformat == 'I'))
        {
            fprintf(stderr, "Output will contain IBM floating-point format\n");
            floatconvert = CIBM;
        }
        else if ((*oformat == 'e') || (*oformat == 'E'))
        {
            fprintf(stderr, "Output will contain IEEE floating-point format\n");
            floatconvert = CIEEE;
        }
        else if ((*oformat == 'b') || (*oformat == 'B'))
        {
            /* In this case BOTH IBM and IEEE have been requested */
            fprintf(stderr, "Output will contain both IBM and IEEE formats\n");
            floatconvert = CBOTH;
            fprintf(stderr, "ERROR: -F b not yet supported.\n");
            cmderr++;
        }
        else {
            fprintf(stderr, "ERROR: -F parameter may be i or e and not %c\n",
                    *oformat);
            cmderr++;
        }
    }
    
    
    /*
	 ** If something went wrong, whinge and die ...
	 */
    if (cmderr)
    {
        fprintf(stderr, "Command Error (%d)\n", cmderr);
        fprintf(stderr, "\n");
        fprintf(stderr, "Usage: %s <options>\n", argv[0]);
        fprintf(stderr, "  Options:-\n");
        fprintf(stderr, "   -i <filename>   Input STH File base    [No Default]\n");
        fprintf(stderr, "   ( -i may be split into -f, -t, -d naming the three\n");
        fprintf(stderr, "     separate File Header, Trace Header, and Data files:\n");
        fprintf(stderr, "     -f <filename> Input STH File Header file\n");
        fprintf(stderr, "     -t <filename> Input STH Trace Header file\n");
        fprintf(stderr, "     -d <filename> Input STH Trace Data file )\n");
        fprintf(stderr, "   -o <filename>   Output SEG File Name   [No Default]\n");
        fprintf(stderr, "   -D <directory>  Output directory name  [Default ./]\n");
		fprintf(stderr, "   -v              Show version of this program\n");
        fprintf(stderr, "   -P <X/I/T/N>    Slice Type (Optional)  [Default N]\n");
        fprintf(stderr, "   -B <number>     First Slice parameter  [Default 0]\n");
        fprintf(stderr, "   -S <number>     Second Slice parameter [Default 1]\n");
        fprintf(stderr, "   -n <number>     Max. no. output files  [Default 10]\n");
        fprintf(stderr, "   -I <number>     Column of INline in TH [Default 187]\n");
        fprintf(stderr, "   -X <number>     Column of CROSSline TH [Default 193]\n");
        fprintf(stderr, "   -h <filecount>  (Optional) Trace Header file count value\n");
        fprintf(stderr, "   -r <rec_count>  (Optional) Trace Header SEGY count value\n");
        fprintf(stderr, "   -F <i / e>      Float type convert     [Default none]\n");
        fprintf(stderr, "   -e <length>     Extra TH leng. skip    [Default 0]\n");
        fprintf(stderr, "   -l              Use FH sample count throughout\n");
        fprintf(stderr, "   -u              Use TH sample count    [Default]\n");
        fprintf(stderr, "   -A              Do not check Inline    range limit\n");
        fprintf(stderr, "   -G              Do not check Crossline range limit\n");
        fprintf(stderr, "   -C              Do not check Timeline  range limit\n");
        if (NeverSwap == 0)
        {
            fprintf(stderr, "   -E <b / l>      Endian of input file [Default b(ig)]\n");
            fprintf(stderr, "   -O <b / l>      Endian of output file[Default b(ig)]\n");
        }
        //        fprintf(stderr, "   -T <debug>      (DEBUG ONLY) Trace   [Default 0]\n");
        fprintf(stderr, "\n");
		fprintf(stderr, "Program Version %s %s\n", STHVERSION, STHDATE);
        fprintf(stderr, "Program Name:   %s : %s\n", progname, argv[0]);
        fprintf(stderr, "\n");
		
        exit(PARAM_ERROR);
    }

    /*  INDICATE THE PARAMETER VALUES FOR THIS RUN  */
    
    /*
	 *  Tell the user what the values are of the parameters, as read and as
	 *  taken by default:
	 */
	fprintf(stderr, "\nProgram %s is being run with following options:\n\n"
            ,progname);
	fprintf(stderr, "Program Version %s %s\n", STHVERSION, STHDATE);
 	fprintf(stderr, 
            "Input file names:  %s\n"
            "                   %s\n"
            "                   %s\n", 
            fhnamein, thnamein, tdnamein);
    if (sliceform != 0)
    {
        /*
         *  This is a Slice - so lots of output files:
         */
        fprintf(stderr, "Output file names: (base) %s\n",
                fnameout);
    }
    else 
    {
        /*
         *  This is not a Slice - so only one file output:
         */
        fprintf(stderr, "Output file name:  %s\n", fnameout);
    }

    
    if (nonulls != 0)
    {
        fprintf(stderr, "Do not copy leading null characters in first chunk\n");
    }
    else 
    {
        fprintf(stderr,
                "Retain, and copy, %d leading nulls in initial chunks\n",
                FileNameMax);
    }
    
    if (WriteTwo != 0)
    {
        fprintf(stderr, "Insert 2-byte count preceding LOB\n");
    }
    if (WriteFour != 0)
    {
        fprintf(stderr, "Insert 4-byte (2+2) count preceding LOB\n");
    }
    if (Write64 != 0)
    {
        fprintf(stderr, "Insert 8-byte (64-bit) count preceding LOB\n");
    }
    if ((WriteTwo == 0) && (WriteFour == 0) & (Write64 == 0))
    {
        fprintf(stderr, "Insert no extra count preceding data LOB\n");
    }
    
    if (oformat != (char *)NULL)
    {
        if (floatconvert == CIBM)
        {
            fprintf(stderr, "Floating point output is in IBM format\n");
        }
        else if (floatconvert == CIEEE)
        {
            fprintf(stderr, "Floating point output is in IEEE format\n");
        }
    }
    
    if (THfcUSE >= 0)
    {
        fprintf(stderr, "Trace sequence number within line is %d\n",
                THfcUSE);
    }
    else
    {
        fprintf(stderr, "Trace sequence number within line taken from input\n");
    }
    if (THscUSE > 0)
    {
        fprintf(stderr, "Trace sequence number within SEGY file begins at %d\n",
                THscUSE);
    }
    else
        if (THscUSE == 0) {
            fprintf(stderr, "Trace sequence number in SEGY file starts at 1 (one)\n");
        }
        else
        {
            THscUSE = -1;
            fprintf(stderr, "Trace sequence number in SEGY file taken from input\n");
        }
    
    if (ExtraTH != 0)
    {
        fprintf(stderr, "Extra Trace Header skip of %d bytes\n", ExtraTH);
    }
    
    /* Check and display the endian indicators, if any: */
    if (pin_end != (char *)NULL)
    {
        if ((*pin_end == 'b') || (*pin_end == 'B'))
        {
            input_endian = BIG;
            fprintf(stderr,"Input file  is  Big   endian\n");
        }
        else if ((*pin_end == 'l') || (*pin_end == 'L'))
        {
            input_endian = LITTLE;
            fprintf(stderr,"Input file  is Little endian\n");
        }
        else
        {
            fprintf(stderr," ERROR: Input endian -E may be b or l not %c\n",
                    *pin_end);
            exit(BAD_INPUT_END);
        }
    }
    else
    {
        fprintf(stderr,     "Input file  is  Big   endian (default)\n");
    }
    
    if (pout_end != (char *)NULL)
    {
        if ((*pout_end == 'b') || (*pout_end == 'B'))
        {
            output_endian = BIG;
            fprintf(stderr, "Output file is  Big   endian\n");
        }
        else if ((*pout_end == 'l') || (*pout_end == 'L'))
        {
            output_endian = LITTLE;
            fprintf(stderr, "Output file is Little endian\n");
        }
        else
        {
            fprintf(stderr,"ERROR: Output endian -O may be b or l not %c\n",
                    *pout_end);
            exit(BAD_OUTPUT_END);
        }
    }
    else
    {
        fprintf(stderr,    "Output file is  Big   endian (default)\n");
    }
    
    if (NeverSwap !=0)
    {
        if ((pin_end != (char *)NULL) || (pout_end != (char *)NULL))
        {
            fprintf(stderr, "Warning: No file endian-swap will take place -\n"
                    "         Not yet supported.\n");
            /* Force defaults: */
            input_endian = BIG;
            output_endian = BIG;
        }
    }
    
    fprintf(stderr, "INline column (displacement) in TH is    %d (%d)\n", 
            disp_inline, (disp_inline - 1));
    fprintf(stderr, "CROSSline column (displacement) in TH is %d (%d)\n", 
            disp_crossline, (disp_crossline - 1));
    
    if (rew==0)
    {
        fprintf(stderr,"Pre-existing output files may be overwritten\n");
    }
    else 
    {
        fprintf(stderr,"Pre-existing output files will NOT be overwritten\n");
    }

    
    /* Write one spacing line - to make the printed output look pretty :-)  */
    fprintf(stderr, "\n");
    

    /* >>> Start of main processing <<< */
    
    /*
     *  There are two top-level operations here:
     *  1)  read and record in memory the File Header information
     *  2a) read each individual Trace Header record, and for each of these
     *  2b) read the appropriate Trace Data words, and for each such word
     *      generate a file containing:
     *      a) a single copy of the File Header record,
     *      b) a single copy of a Trace Header record (adjusted), and
     *      c) one data sample word.
     *  Note that we do not know how many output SEG Y files this program is
     *  going to generate until we have read the first Trace Header record.
     *
     *  But here we start with reading the File Header information, as given
     *  by the STH database query, and constructing a correctly-formatted SEGY
     *  File Header + Binary Header record.
     */
    
    
    /*  Part One : FILE HEADER  */
    
    /*
     *  Open and Read the File Header input:
     */
    l = fread(FHrec,sizeof(unsigned char),LEN_FH,fhipf);
    iFHlength = iFHlength + l;   /*  Count length of record read  */
    if (l != LEN_FH)
    {
        fprintf(stderr,
                "ERROR: File Header record not read successfully, l=%d\n"
                "       errno = %d\n", l, errno);
        fprintf(stderr,"       Program terminates.\n");
        exit(BAD_FILE_HEADER);
    }
    
    /*
     *  Remember the relevant fields from this File Header.
     *  First the expected number of samples per trace:
     */
    nsamples = 0;
    memcpy(&nsamplesFH,&FHrec[(PFH_SAMPTHISR) - (PFH_START)],LFH_SAMPTHISR);
    if (thisendian != input_endian)
    {
        nsamplesFH = swap_int16(nsamplesFH);
    }
    /*
     *  Look at the Fixed Length Trace Flag to determine whether we should
     *  be using the sample count from the File Header, or we should use
     *  the (possibly different) sample count from the Trace Header:
     */
    memcpy(&UseFHsamp,&FHrec[(PFH_FLTRFLG) - (PFH_START)],LFH_FLTRFLG);
    memcpy(&FmtRevNo,&FHrec[(PFH_SEGYREVNO) - (PFH_START)],LFH_SEGYREVNO);
    if ((FmtRevNo[0] == '\0') && (FmtRevNo[1] == '\0') && (UseTHsamp == 0))
    {
        UseFHsamp = 1;
        UseTHsamp = 0;
        fprintf(stderr,
                "INFO: Using sample count from File Header throughout.\n");
    }
    if (UseFHsamp == 0)
    {
        UseTHsamp = 1;
        fprintf(stderr,
                "INFO: Using sample count from Trace Header records throughout.\n");
    }
    else 
    {
        nsamples = nsamplesFH;
    }
    
    /*
     *  At this point we have only one of UseFHsamp and UseTHsamp as non-zero,
     *  and if UseFHsamp is non-zero, then nsamplesFH contains the expected
     *  count of samples per trace for all trace records in this extract, as
     *  does nsamples.
     */

    /*
     *  Get the data sample format code, and compute the type length for this
     *  data:
     */
    memcpy(&typelenwk,&FHrec[(PFH_DATSAMPFC) - (PFH_START)],LFH_DATSAMPFC);
    if (thisendian != input_endian)
    {
        typelenwk = swap_int16(typelenwk);
    }
    if ((typelenwk >0) & (typelenwk <= MAXTYPE))
    {
        typelength = typelens[typelenwk-1];
    }
    else 
    {
        /*
         *  The data type specified in the FH record is not, strictly, valid, 
         *  We assume the length of each sample is 4 bytes, and warn the user:
         */
        typelength = 4;
        fprintf(stderr,
                "WARNING: Type length assumed to be 4, type %d specified in FH\n",
                typelenwk);
    }
    datatype = typelenwk;
    
    /*
     *   Check the datatype as recorded in the header record against the
     *   conversion that is requested by the user. If these are the same type 
     *   then there is no conversion to be performed:
     */
    if ((datatype == TYPEIBM32) && (floatconvert == CIBM))
    {
        floatconvert = NOCONVERT;
    }
    else if ((datatype == TYPEIEEE32) && (floatconvert == CIEEE))
    {
        floatconvert = NOCONVERT;
    }
    
    /*  
     *  Construct, ready to write, the File Header + Binary Header of the output:
     *  Firstly, we have to flip the bit-ordering if the input and the
     *  output are different:
     */
    if ((NeverSwap == 0) && 
        (input_endian != output_endian))
    {
        for (j=0;j<LEN_FH_4;j=j+4)
        {
            cc = FHrec[j];
            FHrec[j] = FHrec[j+3];
            FHrec[j+3] = cc;
            cc = FHrec[j+2];
            FHrec[j+2] = FHrec[j+1];
            FHrec[j+1] = cc;
        }
    }
    
    /*
     *  If there are any subsidiary file headers, this is where to read (and
     *  write) them. Note that the length of the subsidiary (auxilary) file
     *  headers have a shorter length - as we have included the binary header
     *  in with the first file header.
     */
    memcpy (&nauxfh, &FHrec[(PFH_NETFHREC) - (PFH_START)], LFH_NETFHREC);
    if (thisendian != input_endian)
    {
        nauxfh = swap_int16(nauxfh);
    }
    fprintf(stderr, "Number of Auxiliary File Header records = %d\n", nauxfh);
    
    /*
     *  Verify that we have reached the end of the input File Header file.
     *  We could do this by doing one more read, ensuring that the length read 
     *  is zero, and verifying that the feof flag is set - but for the moment
     *  we do not have that code present.
     */
//    maxnaux = nauxfh;
    
    /*
     *  This program does NOT support auxillary input File Header records:
     */
    if (nauxfh != 0)
    {
        fprintf(stderr, "ERROR: Auxilliary File Header input not supported\n"
                "       Program terminates.\n");
        exit (BAD_AUX_FHEAD);
    }
    
    /*
     *  At this point we have read and remembered the whole of the first File
     *  Header record (with Binary Header). To check that we are the end of
     *  the File Header input file we perform one more read, and verify that
     *  we have both (a) read nothing, and also (b) we are at end-of-file:
     */
    
    l = fread(FHrec,1,FHSIZE,fhipf);
    /* Do NOT count this read, in the input count, as it should be zero */
    if (l != 0)
    {
        fprintf(stderr, "ERROR: Extra File Header information presented - \n"
                "       of length %d.\n"
                "       errno = %d\n"
                "       Program terminates.\n", l, errno);
        exit(BAD_EXTRA_FH1);
    }
    l = feof(fhipf);
    if (l == 0)
    {
        fprintf(stderr, "ERROR: Extra File Header information presented -\n"
                "       of unknown length.\n"
                "       errno = %d\n"
                "       Program terminates.\n", errno);
        exit(BAD_EXTRA_FH2);
    }
    else 
    {
        fprintf(stderr, "All File Header input processed successfully\n");
    }
    
    /*
     *  Close the File Header input file:
     */
    tfclose(fhipf);
    fhipf = (FILE *)NULL;
    if (tprint != 0)
    {
        fprintf(stderr, "File Header output bytes:  %d\n", FHlength);
    }

    /*  Part two: TRACE HEADER and DATA  */
    
    /*
     *  This is a loop, reading first the trace header, then the corresponding
     *  data for that header, and writing these to the output. The loop ends
     *  when there is no more input from the Trace Header input file.
     *  The data count in the very first trace header is used to determint the
     *  number of output files that we need to open. Each output file is primed
     *  with a copy of the (remembered) Trace Header record.
     */
    while (TraceEnd == 0)
    {   /*  MAIN DATA LOOP START  */
                
        /*  Read in the next Trace Header record: */
        l = fread(THrec,1,LEN_TH+ExtraTH,thipf);
        iTHlength = iTHlength + l;
                
        /*
         *  Check whether we have read the correct amount - if not, then we
         *  may be at the end of the Trace Header input file:
         */
        if (l != LEN_TH+ExtraTH)
        {
            /*
             * Indicate, no matter what, that we must not read any more of
             * the input Trace Header file:
             */
            TraceEnd = 1;
            if (l == 0)
            {
                /*
                 *  The amount read in was zero - if we are at feof, then all
                 *  is well. If, however, we are not at feof, then there is
                 *  something wrong:
                 */
                i = feof(thipf);
                if (i == 0)
                {
                    fprintf(stderr, "ERROR: Trace Header input file not "
                            "correctly terminated\n"
                            "       Error is after %d records\n"
                            "       Program terminates.\n", TraceCount);
                    exit(BAD_EOF_ITH);
                }
                
                /*
                 *  We have reached end of file on the TH file - we *should* 
                 *  also be at end of file on the data file - check that this is
                 *  the case, and if not warn the user:
                 */
                l = fread(&TDDataLength, 1, 2, tdipf);
                if (l != 0)
                {
                    /* problem */
                    fprintf(stderr,
                            "WARNING: After processing all %d Trace Headers\n"
                            "         there is still some data unprocessed\n"
                            "         errno = %d\n", TraceCount, errno);
                    fprintf(stderr,
                            "         Program terminates\n");
                    /*
                     *  We could un-comment the following exit statement - but 
                     *  since the only thing this program now does (in any case)
                     *  is to print the trailing messages and stop, we allow
                     *  flow to continue and for that to happen.
                     *  IF we ever add anything further to this program, 
                     *  following the main data-processing loop, then we MUST
                     *  un-comment this exit call:
                     */
                    //                    exit(BAD_MISSING_DATA);
                }
                else 
                {
                    /*
                     *  We did not read anything from the data file - which is
                     *  good - but now check that we are at end of file:
                     */
                    l = feof(tdipf);
                    if (l == 0)
                    {
                        /*
                         *  Ah - a problem - we are not, strictly, at end of
                         *  file on the data file, even though we know there is
                         *  nothing else to read from it. We know that we have
                         *  actually processed all the incoming data - so just
                         *  warn the user that something obscure is amis:
                         */
                        fprintf(stderr,
                                "WARNING: End-of-file not correctly detected on data file:\n"
                                "         All data appears to have been processed\n");
                    }
                    else 
                    {
                        /*
                         *  This is good - both the TH and the TD files are at
                         *  end-of-file, and both have been completely read.
                         */
                        fprintf(stderr, "Both Trace Header and Trace data "
                                "files processed completely.\n");
                    }
                }
            }
        }
        else 
        {
            /*
             *  The Trace Header record was successfully read. Save the 
             *  relevant information from this record. First, we determine
             *  whether we should be using this Trace Header record for the
             *  count of number of samples: if so, get that count...
             */
            TraceCount++;  /*  Count number of Trace Headers read  */
            
            memcpy(&nsamplesTH, &THrec[(PTH_NOSAMPTR) - (PTH_START)],
                   LTH_NOSAMPTR);
            memcpy(&ThisIn,    &THrec[disp_inline],    len_inline);
            memcpy(&ThisCross, &THrec[disp_crossline], len_crossline);
            /*
             *  Correct the Crossline number and Inline numbers used in this
             *  code for the enian-ness of this machine. This needs to be done
             *  only if "this" and "input" endians are different:
             */
            if (thisendian != input_endian)
            {
                ThisIn = swap_int32(ThisIn);
                ThisCross = swap_int32(ThisCross);
            }
            
            /*
             *  If this is the first Trace Header record then we have, for the
             *  first time, information as to how many actual output files we are
             *  going to be generating. This number is in the "nosamptr" field
             *  (number of samples in this trace) +115-116.
             *  Open the output files, indicating this to the user:
             */
            
            usensamplesTH = nsamplesTH;

            if (usensamplesTH>MAXOUTFILES)
            {
                /*
                 *  There are too many samples to create all the files at the
                 *  same time, so set an upper limit. NOTE that this should, in
                 *  production, also raise an error message:
                 */
                usensamplesTH = MAXOUTFILES;
            }

            if (usensamplesTH>noutputfiles)
            {
                /*
                 *  There are more samples in the input than the user has asked
                 *  for on the command line. NOTE that in production this could
                 *  also raise a warning/information message:
                 */
                usensamplesTH = noutputfiles;
            }

            /*
             *  This is the first TH record to be read, so we now have to
             *  open the output file or files. The number - and name - of 
             *  the files to open depends upon the slice type.
             *  -P n  (Normal) There is no slicing, so only one output file
             *        is required. This is the default for this program.
             *  -P x  (Crossline) There will be a series of output files,
             *        a different one for each Inline.  
             *  -P i  (Inline) There will be a series of output files, a
             *        different one for each Crossline. 
             *  -P t  (Timeline) There are a number of output files, one
             *        for each timeslice being processed. The number opened
             *        is the minimum of (a) the number of data samples in
             *        this first point, (b) the maximum number of files that
             *        can be opened at once (in the value MAXOUTFILES).
             *        CHANGE: Version 0.56 onwards (Timeline) There are a
             *        series of output files, a different one for each
             *        Inline (very similar to -P x)
             */
            if ((sliceform == 0))
            {
                /* There is NO slicing - only one output file: 
                 * Check whether this is already open, and if not
                 * then create and open it:
                 */
                if (opf[0] == (FILE *)NULL)
                {
                    /*
                     *  Set the only output file name to be the base name, 
                     *  within the -d specified directory (if any):
                     */
                    if (odirname != (char *)NULL)
                    {
                        strcpy(&fnameoutD[0][0], odirname);
                        strcat(&fnameoutD[0][0], fnameout);
                    }
                    else 
                    {
                        strcpy(&fnameoutD[0][0], fnameout);
                    }
                    /* Version 0.56: append '.sgy' to the constructed filename */
                    /* Version 0.66: Addition of '.sgy' REMOVED for non-slicing case: */
//                    strcat(&fnameoutD[0][0], ".sgy");

                    usensamplesTH = 1;
                    
                    /* Open the file: */
                    /* Version 0.52 onwards: Do we allow overwrite of an
                     * existing file? If so, simply open the file for output,
                     * but if not, test whether the file exists, and simply
                     * return to caller:
                     */
                    if (rew!=0)
                    {
                        opf[0] = fopen ( &fnameoutD[0][0], "r");
                        if (opf[0] != (FILE *)NULL)
                        {
                            /* The file already exists - quit and return to caller */
                            fprintf(stderr,
                                    "ERROR: Output file already exists - Will NOT be overwritten\n");
                            fprintf(stderr, "       Program terminates.\n");
                            exit(BAD_NFILE_EXISTS);
                        }
                    }
                    opf[0] = fopen ( &fnameoutD[0][0], "w");
                    if (opf[0] == (FILE *)NULL)
                    {
                        fprintf(stderr,
                                "ERROR: Unable to open output (Noslice) file [%d] %s\n"
                                "       errno = %d\n"
                                "       Program terminates.\n", 0, 
                                &fnameoutD[0][0], errno);
                        exit(BAD_OUTPUT_OPEN);
                    }
                    else 
                    {
                        fprintf(stderr,
                                "INFO:  Opened output (Noslice) file [%d] %s\n",
                                0, &fnameoutD[0][0]);
                    }
                    /*
                     *  Write the FH record to this output file:
                     */
                    FHlength = FHwrite(&FHrec[0], FHlength1, opf[0], 
                            &fnameoutD[0][0]);
                }
            } /* end of sliceform 0 */
            else /* sliceform is non-zero */
            { 
                /* Crossline or Timeline. If the output file is not open OR if 
                 * this is a different Crossline from the previous one, open a 
                 * new output file:
                 */
                if ((sliceform == 1) || (sliceform == 3))
                {
                    if (ThisCross != PrevCross)
                    { 
                        tfclose(opf[0]);
                        opf[0] = (FILE *)NULL; 
                        PrevCross = ThisCross;
                    }
                }
                else if (sliceform == 2)
                {
                    /* Similarly for InLine split: */
                    if (ThisIn != PrevIn)
                    { 
                        tfclose(opf[0]);
                        opf[0] = (FILE *)NULL; 
                        PrevIn = ThisIn;
                    } 
                }
                else
                {
                    /* Invalid sliceform */
                    fprintf(stderr, "ERROR: Internal error, sliceform = %d\n",
                            sliceform);
                    fprintf(stderr, "       Program terminates.\n");
                    exit(BAD_SLICE_FORM);
                }
                
                /*
                 *  At this point we know that:
                 *  1) sliceform has a valid non-zero value (1, 2 or 3), and
                 *  2) if we have to open a new output file, then the old one
                 *     has been closed.
                 */
                
                if (opf[0] == (FILE *)NULL)
                { 
                    /* Construct the file name: */
                    usensamplesTH = 1;
                    tstring = &work16[0];
                    if (odirname != (char *)NULL)
                    {
                        strcpy(&fnameoutD[0][0], odirname);
                        strcat(&fnameoutD[0][0], fnameout);
                    }
                    else 
                    {
                        strcpy(&fnameoutD[0][0], fnameout);
                    }
                    
                    /*  If we are doing Timeline splitting, then compute the
                     *  timeline number for this new line:
                     */
                    if (sliceform == 3)
                    {
                        if (ThisTime == 0)
                        {
                            ThisTime = firstsample;
                            PrevTime = 0;
                        }
                        else 
                        {
                            PrevTime = ThisTime;
                            ThisTime = ThisTime + samplestep;
                        }

                    }
                    
                    /*
                     *   Finish constructing the filename, and also (if still
                     *   active) check the validity of the new name:
                     */
                    if (sliceform == 1)
                    {
                        if ((SafeCross == 0) &&
                            ((ThisCross < 0) || (ThisCross > MAXCROSSSLICE)))
                        {
                            fprintf(stderr,
                                    "ERROR: Crossline number is outside range [%d]\n"
                                    "       Must be between 0 and %d\n"
                                    "       Program terminates.\n",
                                    ThisCross, MAXCROSSSLICE);
                            exit(BAD_CROSSLINE);
                        }
                        
                        sprintf(tstring, "X%05d.sgy", ThisCross);
                    }
                    else if (sliceform == 2)
                    {
                        if ((SafeIn == 0) && 
                            ((ThisIn < 0) || (ThisIn > MAXINSLICE)))
                        {
                            fprintf(stderr,
                                    "ERROR: Inline number is outside range [%d]\n"
                                    "       Must be between 0 and %d\n"
                                    "       Program terminates.\n",
                                    ThisIn, MAXINSLICE);
                            exit(BAD_INLINE);
                        }
                        
                        sprintf(tstring, "I%05d.sgy", ThisIn);
                    }
                    else 
                    {
                        if ((SafeTime == 0) &&
                            ((ThisTime < 0) || (ThisTime > MAXTIMESLICE)))
                        {
                            fprintf(stderr,
                                    "ERROR: Timeline number is outside range [%d]\n"
                                    "       Must be between 0 and %d\n"
                                    "       Program terminates.\n",
                                    ThisTime, MAXTIMESLICE);
                            exit(BAD_TIMELINE);
                        }
                        
                        sprintf(tstring, "T%05d.sgy", ThisTime);
                    }
                    strcat (&fnameoutD[0][0],tstring);
                    
                    /* Open the file: */
                    if (rew != 0)
                    {
                        opf[0] = fopen ( &fnameoutD[0][0], "r" );
                        if (opf[0] != (FILE *)NULL)
                        {
                            /* The output file already exists - BUT we are NOT
                             * permitted to overwrite it. So close the file, and
                             * set the pointer to it to be NULL so that we do
                             * not attempt to write to this file:
                             */
                            tfclose(opf[0]);
                            opf[0] = (FILE *)NULL;
                            if (sliceform == 1)
                            {
                                fprintf(stderr,
                                        "ERROR: Crossline File %s already exists\n", 
                                        &fnameoutD[0][0]);
                                exit(BAD_XFILE_EXISTS);
                            }
                            else if (sliceform == 2) 
                            {
                                fprintf(stderr,
                                        "ERROR: Inline File %s already exists\n", 
                                        &fnameoutD[0][0]);
                                exit(BAD_IFILE_EXISTS);
                            }
                            else
                            {
                                fprintf(stderr,
                                        "ERROR: Timeline File %s already exists\n", 
                                        &fnameoutD[0][0]);
                                exit(BAD_TFILE_EXISTS);
                            }
                        }
                    }
                    
                    /*
                     *  File does NOT already exist - so open it for writing, 
                     *  and write the initial File Header:
                     */
                    opf[0] = fopen ( &fnameoutD[0][0], "w" );
                    if (opf[0] == (FILE *)NULL)
                    {
                        fprintf(stderr,
                                "ERROR: Unable to open output file [%d] %s\n"
                                "       errno = %d\n"
                                "       Program terminates.\n", 0, 
                                &fnameoutD[0][0], errno);
                        exit(BAD_OUTPUT_OPEN);
                    } 
                    else 
                    { 
                        fprintf(stderr,
                                "INFO:  Opened output file [%d] %s\n",
                                0, &fnameoutD[0][0]);
                    } 
                    /*
                     *  Write the FH record to this output file:
                     */

                    FHlength = FHwrite(&FHrec[0], FHlength1, opf[0], 
                            &fnameoutD[0][0]);
                } 
            } /* Non-zero sliceform */ 
                        
                
            if (thisendian != input_endian)
            {
                nsamplesTH = swap_int16(nsamplesTH);
            }
            if (UseTHsamp != 0)
            {
                nsamples = nsamplesTH;
            }

            /*
             *  Remember the count of samples (a) used, (b) according to FH 
             *  record, and (c) according to TH records:
             */
            TotalSamples = TotalSamples + nsamples;
            TotalSamplesFH = TotalSamplesFH + nsamplesFH;
            TotalSamplesTH = TotalSamplesTH + nsamplesTH;
            
            /*
             *  If we are modifying the first two fields in the Trace Header,
             *  here is the place to do it:
             */
            if (THfcUSE >= 0)
            {
                /* NOTE: this field value does NOT change (hence comment out) */
                //                THfilecount = swap_int32(THfcUSE);
                //                THfcUSE++;
                memcpy(&THrec[0],&THfilecount,4);
            }
            /* 
             *  Note that if THfcUSE is negative, then we do not alter the input
             *  value, but leave the buffer untouched
             */
            
            if (THscUSE >= 0)
            {
                /* NOTE: but this field DOES change in value */
                THsegcount = swap_int32(THscUSE);
                THscUSE++;
                memcpy(&THrec[4],&THsegcount,4);
            }
            /*
             *  Note that if THscUSE is negative, then we do not alter the input
             *  value, but leave the buffer untouched
             */
            
            /*
             *  Now write the Trace Header record to the SEGY output files, and
             *  count the amount of data written:
             *  If we need to endian-flip the buffer, do so now:
             */
            i = LEN_TH_4;
            if ((NeverSwap == 0) && 
                (input_endian != output_endian))
            {
                for (j=0;j<i;j=j+4)
                {
                    cc = THrec[j];
                    THrec[j] = THrec[j+3];
                    THrec[j+3] = cc;
                    cc = THrec[j+2];
                    THrec[j+2] = THrec[j+1];
                    THrec[j+1] = cc;
                }
            }

            usensamplesTH = 1;
            
            /*
             *  Write the Trace Header record:
             *  Only if the output file is open:
             */
            if (opf[0] != (FILE *)NULL)
            {
                l = FHwrite(&THrec[0], THlength1, opf[0], &fnameoutD[0][0]);
                if (l != LEN_TH)
                {
                    fprintf(stderr,
                            "ERROR: Trace Header record not complete - length %d\n"
                            "       errno = %d\n", l, errno);
                    fprintf(stderr, "       File [%d] %s incomplete\n", 
                            0, fnameoutD[0]);
                    fprintf(stderr, "       Program terminates.\n");
                    exit(BAD_FH_WRITE1);
                }
            }
            
            THlength = THlength + LEN_TH; /* Count length of record written */
            
            /*
             *  We now know how much data we expect from the Trace Data input
             *  file. Read in this much data, together with the record
             *  prefix. The length of the data record to read in is...
             *     typelength * nsamples
             */
            
            /*  ASSUME that we get all the chunks together - i.e. that this
             *  program does NOT have to de-chunk....
             *  ... actually, that appears to be wrong, and we *do* have to
             *  de-chunk, by reading slices of data, and recomposing them into
             *  the slabs of data. Note that the slabs of data we write in this
             *  way do NOT have a preceding four-byte count word, but MAY have
             *  a preceding 64-bit LOB count (this has still to be decided in
             *  versions beyond 0.31)
             */
            
            /*
             *  Set the dechunking counters to the start of the first chunk in
             *  a set
             */
            chunkstart = 1;
            sampthisset = nsamples;
            
            if (SkipReadData == 0)
            {
                /*
                 *  Design for version 0.35:
                 *  B: are there any more samples expected for this record?
                 *     if NO, go to A:
                 *  read two-byte length
                 *  set skip length to 2
                 *  is this the first chunk in the set?
                 *     if NO, go to C
                 *     compute LOB prefix(es)
                 *     set skip length to 18
                 *  C: 
                 *  read remainder of this chunk
                 *  compute length of output to write, bearing in mind (a)
                 *  whether to skip 16 of the 18 bytes, and (b) whether we
                 *  are using (1) two-byte or (2) eight-byte or (3) no
                 *  preceding length field.
                 *  Write the length field(s) (if needed, and this is the first
                 *  chunk of the set)
                 *  Write the rest of the chunk that we have read
                 *  Count the number of samples written, and used from this
                 *  chunk, and still expected from future chunks in this set
                 *  go to B
                 *  A:
                 */
                while (sampthisset > 0) /* B: */
                {
                    /*
                     *  We have to read in just two bytes from the data file
                     *  to determine the length of the remainder of the data
                     *  record:
                     */
                    l = fread(&TDDataLength, 1, 2, tdipf);
                    /*
                     *  Check whether this record was correctly read:
                     */
                    if (l != 2)
                    {
                        //                        TraceEnd = 1; /*  Set end of large copy loop  */
                        fprintf(stderr, "ERROR: END detected in reading data length\n"
                                "       record %d bytes expected %d but read only %d\n"
                                "       Program terminates.\n",
                                TraceCount, 2, l);
                        exit (BAD_DATA_READ);
                    }
                    m = TDDataLength; /*  and save for later - to output  */
                    if (thisendian != input_endian)
                    {
                        m = swap_int16(m);
                    }
                    ReadLength = m;
                    //                    RecordLength = m + 2;
                    if (ReadLength < 0)
                    {
                        fprintf(stderr, "ERROR: record %d length calculated %d\n"
                                "       Program terminates\n",
                                TraceCount, ReadLength);
                        exit(BAD_DATA_LENGTH);
                    }
                    
                    /*
                     *   We are happy that this length has been correctly read.
                     */
                    skiplength = 2;
                    if (chunkstart != 0)
                    {
                        /*
                         *  If we are skipping the nulls at the start of the
                         *  first chunk, then indicate that here:
                         */
                        if (nonulls != 0)
                        {
                            skiplength = skiplength + FileNameMax;
                        }
                        /*
                         *  Compute the LOB length here:
                         */
                        LOBlength = nsamples * typelength;
                        LOBlength2 = LOBlength;
                        sn = LOBlength - 2;
//                        LOBlength64 = LOBlength;
                        /*
                         *  Convert these lengths to big endian:
                         */
                        if (thisendian != input_endian)
                        {
                            LOBlength = swap_int16(LOBlength);
                            LOBlength2 = swap_int32(LOBlength2);
//                            LOBlength64 = swap_double(LOBlength64);
                            sn = swap_int16(sn);
                        }
                        
                        memcpy(&cLOBlength4,&LOBlength2,2);
                        sn = LOBlength - 2;
                        memcpy(&cLOBlength4[2],&sn,2);
                    }
                    /* C: */
                    /*
                     *  Get the rest of this chunk:
                     */
                    l = fread(DataBuffer, 1, ReadLength, tdipf);
                    WriteLength = ReadLength;
                    iTDlength = iTDlength + l + 2;  /*  Remember data length read, with prefix  */
                    /*
                     *  Check whether this chunk-end was correctly read:
                     */
                    if (l != ReadLength)
                    {
                        fprintf(stderr,
                                "ERROR: END detected in reading data\n"
                                "       Length expected %d bytes, but read %d bytes\n"
                                "       Record number %d\n"
                                "       (Input lengths  %d %d %d)\n"
                                "       (Output lengths %d %d %d)\n"
                                "       errno = %d\n"
                                "       Program terminates\n",
                                ReadLength, l, TraceCount,
                                iFHlength, iTHlength, iTDlength, 
                                FHlength,  THlength,  TDlength, errno);
                        exit (BAD_DATA_READ2);
                    }
                    
                    /*
                     *  Indicate we are no longer in the first chunk: 
                     */
                    chunkstart = 0;
                    
                    /*
                     *   Write chunk data:
                     */
                    WriteLength = WriteLength - skiplength;
                    /*
                     *  Since there was a two-byte length, it is followed by a
                     *  second two-byte length, which we skip:
                     */
                    skiplength++;  
                    /*
                     *  We are now about to write the chunk data... but if there
                     *  is floating-point conversion to perform, this is where
                     *  it must take place. The number of 4-byte fields to
                     *  convert is (WriteLength/4) - and this should divide
                     *  exactly, with no remainder. If there *is* a remainder 
                     *  then we have a problem, kids!
                     *  The conversion is done from DataBuffer to DataBuffer,
                     *  without using any other long buffer.
                     *  If this is a situation where we are NOT going to be
                     *  writing any output, skip this computationally expensive
                     *  step:
                     */
                    if (opf[0] != (FILE *)NULL)
                    {
                        if (floatconvert != NOCONVERT)
                        {
                            j = WriteLength>>2;
                            if (floatconvert == CIBM)
                            {
                                ieee2ibm(&DataBuffer[skiplength-1], 
                                         &DataBuffer[skiplength-1], j);
                            }
                            else if (floatconvert == CIEEE)
                            {
                            ibm2ieee(&DataBuffer[skiplength-1], 
                                     &DataBuffer[skiplength-1], j);
                            }
                        }
                    /*
                     *  The data to be written may have to be endian-swapped -
                     *  if so, do that here:
                     */
                        if ((NeverSwap == 0) && 
                            (input_endian != output_endian)) 
                        {
                            for (j=0;j<WriteLength;j=j+4)
                            {
                                i=skiplength-1+j;
                                w4 = swap_single((uint32_t)DataBuffer[i]);
                                memcpy((void *)&DataBuffer[i],pw4,4);
                            }
                        }
                    }
                    
                    /* Write this record only if the output file is open: */
                    if (opf[0] != (FILE *)NULL)
                    {
                        l = FHwrite(&DataBuffer[skiplength-1], WriteLength,
                                    opf[0], &fnameoutD[0][0]);
                                        
                        /*
                         *  Check this was written correctly:
                         */
                        if (l != WriteLength)
                        {
                            fprintf(stderr, "ERROR: Problem in writing record %d\n"
                                "       Tried to write %d bytes, but wrote %d bytes\n"
                                "       errno = %d\n"    
                                "       Program terminating",
                                TraceCount, WriteLength, l, errno);
                            exit(BAD_DATA_WRITE);
                        }
                    }
                    else 
                    {
                        fprintf(stderr, 
                                "DEBUG: Data record writing suppressed at %d, %d\n",
                                TDlength, sampthisset);
                    }

                    
                    /* 
                     *  Remember data amount written:
                     */
                    TDlength = TDlength + WriteLength;  
                    
                    /*
                     *  Count for samples written and still expected:
                     */
                    n = (WriteLength + skiplength -2) / typelength;
                    sampthisset = sampthisset - n;
                }
                /*  END OF chunk  */
            }   /*  End of SkipReadData */
        }  /* End of successful Trace Header read */
    }   /*  MAIN DATA LOOP END ... End of processing one Trace Header + Data */
    
    
    /*  TIDY UP AND FINISH EXECUTION  */
    
    /*
     *  The program has finished processing.
     *  Display information to the user, close the files, and exit:
     */
    if (tprint != 0)
    {
        fprintf(stderr, "DEBUG: TotalSamples %d FH %d TH %d\n", TotalSamples,
                TotalSamplesFH, TotalSamplesTH);
    }
    fprintf(stderr, "\nNumber of Traces written:  %d\n\n", TraceCount);
    fprintf(stderr, "File Header OUTput bytes:  %d\n",     FHlength);
    fprintf(stderr, "Trace Header OUTput bytes: %d\n",     THlength);
    fprintf(stderr, "Data OUTput bytes:         %d\n\n",   TDlength);
    fprintf(stderr, "File Header INput bytes:   %d\n",     iFHlength);
    fprintf(stderr, "Trace Header INput bytes:  %d\n",     iTHlength);
    fprintf(stderr, "Data INput bytes:          %d\n\n",   iTDlength);
    
    /* 
     *  Close files:
     */
    if ( strcmp(ofile, "stdout") != 0 )
    {
            tfclose(opf[0]);
            opf[0] = (FILE *)NULL;
    }
    tfclose(thipf);
    tfclose(tdipf);
    
    return 0;
    
}  /* End of main sth2seg */

/*
 *  Write the File Header record:
 */
/*
 *  Write the FH record to this output file:
 */
int FHwrite (unsigned char *FHrec, int FHlength, FILE *outfile, char *filename)
{
    int l = 0;
    
    l = fwrite(FHrec, 1, FHlength, outfile);
    if (l != FHlength)
    {
        fprintf(stderr,
                "ERROR: Written record not complete - length %d expected %d\n"
                "       errno = %d\n", l, FHlength, errno);
        fprintf(stderr, "       Error writing file %s\n", filename);
        fprintf(stderr, "       Program terminates.\n");
        exit(BAD_FH_WRITE1);
    }
    return l;
}


/*
 * Conditionally close a file, if the pointer is not NULL
 */
int tfclose (FILE *filep)
{
    int ret = 0;
    
    if (filep == (FILE *) NULL)
    {
        return (0);
    }
    else 
    {
        ret = fclose(filep);
        /* NOTE: Do ***NOT*** un-comment the following statement, as the file
         *       being closed *might* be stdin or stdout or stderr
         */
//        filep = (FILE *)NULL;
        return ret;
    }
}


/*******************************************************************************
 *  cnvsth2seg.c		
 *  Copyright (c) 2013 Westheimer Energy Consultants Ltd ALL RIGHTS RESERVED
 ******************************************************************************/

