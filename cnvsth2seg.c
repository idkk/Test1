/*******************************************************************************
 *  cnvsth2seg.c		
 *  Copyright 2013 Westheimer Energy Consultants Ltd ALL RIGHTS RESERVED
 ******************************************************************************/

/* This file last updated 20130608:1145 */

/*
 *  This program reads three streams of input, and constructs several streams
 *  of output. The three input streams are all extracted from the STH database,
 *  and are (1) the File Header information, (2) the Trace Header information -
 *  with all trace headers consecutive, and (3) the Trace Data information, with
 *  all the trace data consecutive. We do not have to consider the original
 *  chunking of the data, as created by program seg2sth, as all the data chunks
 *  will have been concatenated by the database extract process.
 *  The output files are SEG-Y files, each containing one time-slice from the
 *  trace data. each output SEG-Y file consists of (1) the File Header inform-
 *  ation (the same for all files), (2) a series of alternately (a) a Trace 
 *  Header record, and (b) a Trace Data record containing the relevant Trace
 *  Data samples. There are *four* different possible patterns of output:
 *  a) No Split: all the incoming Trace Data is produced in a single output
 *     file;
 *  b) Inline Split: there are a series of output files, each containing the
 *     data for one, and only one, INline;
 *  c) Crossline Split: there are a series of output files, each containing the
 *     data for one, and only one, CROSSline;
 *  d) Timeline Split: there are a series of output files - the number of files
 *     is limited by the number of files which can simultaneously be open, and
 *     by the number of samples presented per input point. Each output file
 *     contains the data for one, and only one, timeslice.
 *  The names of the output SEG-Y files are constructed from:
 *  (1) the given directory name (if any), and
 *  (2) the given file-name base, and 
 *  (3) if there is a split, then 
 *      (a) an underscore-letter-underscore, indicating the type of split 
 *          (_I_, _X_, _T_), and 
 *      (b) a number indicating the inline number (for _I_), or the crossline 
 *          number (for _X_), or the vertical sequence number (for _T_) of the 
 *          data in that output slice.
 *
 *  Version 0.52 (upwards): change of file-naming convention:
 *             <survey-name>/iline/I<number>
 *             <survey-name>/xline/X<number>
 *             <survey-name>/tline/T<number>
 *
 *  Each Trace Header record, as received by this program, contains a count of
 *  the number of samples in the Trace Data for that point. For Time-Sliced this 
 *  count is *not* necessarily the original value in the Trace Header records 
 *  (as archived), but may have been constructed by the database retrieve 
 *  process. The value in this field, in the first Trace Header record read, is 
 *  used, for timesliced data, to determine how many output files this program 
 *  will generate. If that value is n then the number of SEG-Y files generated 
 *  by this program is at most n - each containing (a) a copy of the (one and 
 *  only) file header, (b) every Trace Header record, and (c) interleaved 
 *  between the Trace Header records a Trace Data record containing a single 
 *  value. The File Header information is read only once, and held, by this 
 *  program, in memory.
 *
 *  The Trace Header records generated by this program may be altered by this
 *  program, and are *not* necessarily a simple copy of the input. The only 
 *  alteration made (Version 0.51) is to indicate the number of samples in the 
 *  output record as being 1.
 *
 *  There are four different actions we may want this program to perform:
 *
 *  1) Take the three input files and create just one SEG-Y file as output. This
 *     is the same as program cnvsth2seg;
 *
 *  2) Take the three input files, and generate a series of SEG-Y files, each
 *     referring to one, and only one, inline. To do this we have to know the
 *     location of the 'inline' field in the Trace Header record. As the files
 *     are read, when the 'inline' value in the Trace Header drops down, we know
 *     that we have read all the crosslines for the previous inline, and we can  
 *     start the next output file;
 *
 *  3) Take the three input files, and generate a series of SEG-Y files, each
 *     referring to one, and only one, crossline. To do this we have to know the
 *     location of the 'crossline' field in the Trace Header record. As the 
 *     files are read, when the 'crossline' value in the Trace Header drops
 *     down, we know that we have read all the inlines for the previous cross-
 *     line, and we can start the next output file;
 *
 *  4) Take the three input files, and create a series of SEG-Y files (as des-
 *     cribed in the long description earlier), each containing only one data
 *     value for each Trace Header record. As each Trace Data record is read, it
 *     is used to add just one more data value to each of the Seg-Y files being
 *     generated. Note that we have a limit of the number of SEG-Y files that we
 *     can generate at one time, and hence a limit of the number of data values
 *     that can be passed in, for any given point, in one call of this program.
 *     TO DO: It would be possible to extend this program so that there is no
 *     limit to the number of data values that can be passed in, but the program 
 *     could process as many data values as possible (the first tranche), and
 *     then rewind the data file, and process the next tranche, and so on.
 *     similarly, this program could be altered to process just certain spec-
 *     ified data items from the range of data items presented, at any one call.
 *
 *  There are a number of possible parameters that can be passed to this
 *  program, to indicate its input and output file(s), and which time slice(s)
 *  are to be generated.
 *
 *  Option -o is mandatory; either -i must be specified or all of -f -t -d:
 *  -i <filename>  the root of the three filenames, which will be constructed
 *                 as <filename>.ofh and <filename>.oth and <filename>.otd
 *  -o <filename>  the root (base) name of the output files
 *  -f <filename>  file to be used, in lieu of the .ofh file indicated by -i
 *  -t <filename>  file to be used, in lieu of the .oth file indicated by -i
 *  -d <filename>  file to be used, in lieu of the .otd file indicated by -i
 *
 *  Options -n -B -S are optional, and may be deduced from the input files. If
 *  either of options -B or -S are specified, then they are used in generating
 *  the output file names:
 *  -n <number>    Number of output files to generate (default 1, maximum 10)
 *  -B <number>    Subscript of first time-slice data to generate (default 0)
 *  -S <number>    Step-size for subsequent time-slice data (default 1)
 *
 *  Options -X and -I allow the displacements of the INline and CROSSline fields
 *  in the incoming Trace Data records to be specified:
 *  -I <number>    Displacement of INline field in Trace Data - Default 188
 *  -X <number>    Displacement of CROSSline field in Trace Data - Default 192
 *
 *  Option -R indicates whether this program is permitted to overwrite existing
 *  files or not. The default is that existing files will be overwritten with
 *  no comment:
 *  -R <Yes/No>    YES: permit overwrite; NO: do not permit overwrite (default)
 *
 *  Option -u is the default; options -l and -L ARE WITHDRAWN:
 *  -u             Use data lengths only from the TH header records
 /  -L             Data length determined from leading word in TD itself (Dflt.)
 /  -l             Data length determined from FH and TH header records
 *
 *  Options -c -b ARE NO LONGER USED, as the incoming data will already have
 *  been dechunked:
 /  -c <YES/NO>    Dechunk the incoming data - default is YES (also -b)
 *
 *  Options -C -k -K ARE WITHDRAWN:
 /  -C <0/2/4/64>  Insert extra count preceding output LOB
 /  -k <YES/NO>    Remove/do not remove K null characters at start of chunk
 /  -K <number>    Number of characters to remove from start of chunk - dflt. 0
 *
 *  Options -E -O are available, but pre-EAGE (June 2013) not used:
 *  -E <i/e>       Floating-point type of input data (default 'i'=IBM)
 *  -O <i/e>       Floating-point type of output data (default 'e'=IEEE)
 *
 *  Options -1 -2 -3 are temporarily (Version 0.1) WITHDRAWN:
 *  -1             All input is in a single file
 *  -2             Input is in two files: File Header, and TH+TD
 *  -3             (Default) Input is in three files
 *
 *  -v             Show version number of this program
 *
 *  -s             TESTING: data reading is skipped
 *  -T <trace>     TESTING: for debug use only, set trace flag(s)
 *
 */

/*
 * Version history:
 *
 *   0.50          First beta release
 *
 *   0.53          Change of output file naming convention to subdirectories
 *                 Verify generated filenames are within numeric range
 *                 Implement -R parameter to test overwriting permission
 *
 */

/*
 *  TO DO:
 *                 Ensure comments in this code are complete
 *                 Tighten performance to ensure fast running
 *                 Verify size limits within this code
 *        
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>       /* for getopts()   */
#include <sys/types.h>
#include <sys/stat.h>   
#include <stdint.h>
#include <fcntl.h>
#include <math.h>         /* for sqrt()      */

#include "cnvsth2seg.h"

#define DEBUG_LEV 0

#define NEVERSWAP 0

int main (int argc, char * argv[]) 
{
    /*
     *  External routines for handling input parameters:
     */
    extern char *optarg;
    extern int optind, optopt;
    
    /*
     *   Three files are declared, each with a pointer to the command line
     *   parameter, and the FILE pointer, and the saved (or constructed)
     *   file name:
     */
    char *ifhfile = (char *)NULL;    /* File Header Input file name     */
    FILE *fhipf   = (FILE *)NULL;    /* The File Header input file      */
	char fhnamein   [NAMELEN+1];     /* Name of File Header input file  */
    char *ithfile = (char *)NULL;    /* Trace Header Input file name    */
    FILE *thipf   = (FILE *)NULL;    /* The Trace Header input file     */
	char thnamein   [NAMELEN+1];     /* Name of Trace Header input file */
    char *itdfile = (char *)NULL;    /* Trace Data Input file name      */
    FILE *tdipf   = (FILE *)NULL;    /* The Trace Data input file       */
	char tdnamein   [NAMELEN+1];     /* Name of Trace Data input file   */
    char *odirname = (char *)NULL;   /* Name of output directory, if any*/
    char *ofile   = (char *)NULL;    /* Output SEG file name base       */
    FILE *opf[MAXOUTFILES];          /* The Output SEG file pointers    */
	char fnameout   [NAMELEN+1];     /* Name base of Output SEG file    */
    char fnameoutD  [MAXOUTFILES][NAMELEN+1]; /* All Output SEG filenames */
    char alldirname [NAMELEN+1];     /* Output directory name, if any   */
    char *oformat =   (char *)NULL;  /* Output floating-point format    */
    int  input_endian  = BIG;        /* Default endian-ness of input    */
    int  output_endian = BIG;        /* Default endian-ness of output   */
    char *pin_end =   (char *)NULL;  /* Pointer to param. for in_endian */
    char *pout_end =  (char *)NULL;  /* Pointer to param. for out_endian*/

    char *nstr     =  (char *)NULL;  /* -n parameter value              */
    char *Fstr     =  (char *)NULL;  /* -F parameter value              */
    char *Sstr     =  (char *)NULL;  /* -S parameter value              */
    char *tstring  =  (char *)NULL;  /* Pointer to work string          */
    char *slicetype = (char *)NULL;  /* -P parameter value              */
    char *Istr     =  (char *)NULL;  /* -I parameter value              */
    char *Xstr     =  (char *)NULL;  /* -X parameter value              */
    char *rewrite  =  (char *)NULL;  /* -R parameter value              */
    int   noutputfiles = MAXOUTFILES;/* Number of output files to generate    */
    int   currentfile = 0;           /* File number now being generated       */
    int   firstsample = 0;           /* Displacement of first data sample     */
    int   samplestep = 1;            /* Step size in units between samples    */
    int   TH_ONE = 1;                /* Big-endian value one for TH o/p */
    int   fnameD[MAXOUTFILES];       /* Detailed otput file name suffix values*/
    int   sliceform = 0;             /* Type of slicing to be done (if any)  */
    
    
    char  c;                         /* Work variable for parameter unpacking */
    char  cc;                        /* Work variable for character holding   */
    char  work16[16];                /* Work array - temporary strings        */
    int   w4;
    char  *pw4 = (char *)&w4;
    int   thisendian  = ISLITTLE;    /* Endianicty of *this* machine          */
    int   cmderr = 0;                /* Command error indicator - default OK  */
    int   i, j, k, l;                /* Work variables                        */
    unsigned short m, n;             /* Work variables                        */
    short int sn;                    /* Work variable                         */
    int   tprint = 0;                /* Debug trace indicator - default none  */
    int   TraceEnd = 0;              /* Indicate end of Trace Header input    */
    int   TraceCount = 0;            /* Count of Trace (and data) records read*/
    int   FHlength = 0;              /* Length of File Header written         */
    int   THlength = 0;              /* Total length of all Trace Headers out */
    int   TDlength = 0;              /* Total length of all data written      */
    int   iFHlength = 0;             /* Length of File Header read            */
    int   iTHlength = 0;             /* Total length of all Trace Headers IN  */
    int   iTDlength = 0;             /* Total length of all data read         */
//    int   RecordLength = 0;          /* Length of this TD record in bytes     */
    int   CountFilesIn = 3;          /* Number of input files expected 1/2/3  */ 
    int   ExtraTH = 0;               /* Extra bytes in TH record above LEN_TH */
    int   ThisCross = 0;             /* Crossline number for this line        */
    int   ThisIn = 0;                /* Inline number for this line           */
    int   PrevCross = -1;            /* Crossline number for previous line    */
    int   PrevIn = -1;               /* Inline number for previous line       */
    int   disp_inline = 188;         /* Default displacement INline in TH     */
    int   disp_crossline = 192;      /* Defaule displacement CROSSline in TH  */
    int   len_inline = 4;            /* Length of INline field, in bytes      */
    int   len_crossline = 4;         /* Length of CROSSline field, in bytes   */
    unsigned short nauxfh = 0;       /* Number of Auxiliary File Headers      */
//    unsigned short maxnaux = 0;      /* Permanent count of no. of aux FH recs */
    unsigned short nsamplesFH = 0;   /* Number of samples, from File Header   */
    unsigned short nsamplesTH = 0;   /* Number of samples, from Trace Header  */
    int   usensamplesTH = 0;         /* nsamplesTH correct for program limits */
    unsigned short TDDataLength = 0; /* Record length field from input TD     */
    short UseFHsamp = 0;             /* If nonzero, use nsamplesFH            */
    short UseTHsamp = 0;             /* If nonzero, use nsamplesTH            */
    short nonulls = 0;               /* If nonzero, kill leading nulls in brk */
    int   WriteTwo = 0;              /* If nonzero, put two-byte count on LOB */
    int   WriteFour = 0;             /* If nonzero, put 2+2 byte count on LOB */
    int   Write64 = 0;               /* If nonzero, put 64-bit count on LOB   */
    int   nsamples = 0;              /* Consolidated number of samples to use */
    int   sampthisset = 0;           /* No. of samples wanted from this set   */
    int   datatype = 0;              /* Data type as recorded in file header  */
    int   skiplength = 2;            /* Amount of chunk to skip, pre samples  */
    int   chunkstart = 1;            /* If nonzero we are at first chunk      */
    int   THfilecount = -1;          /* File count value to insert in TH      */
    int   THsegcount = -1;           /* SEGY counter to insert in TH          */
    int   THfcUSE = -1;              /* Usable (unswapped) version THfilecount*/
    int   THscUSE = -1;              /* Usable (unswapped) version THsegycount*/
    int   ReadLength = 0;            /* Size of data record to read, in bytes */
    int   WriteLength = 0;           /* Size of data record to write, bytes   */
    int   rew = 0;                   /* Do (0) / Do not (1) allow overwrite   */ 
//    int   UseDataLength = 1;         /* Use TD leading word to find length    */
    int   SkipReadData = 0;          /* Debug trace - skip reading TD data    */
    int   TotalSamples = 0;          /* Debug trace - total number of samples */
    int   TotalSamplesFH = 0;        /* Debug trace - samples as per FH rec.  */
    int   TotalSamplesTH = 0;        /* Debug trace - samples as per TH recs. */
    int   FileNameMax = 16;          /* Length of Filename (?) prefix in chunk*/
    int   LOBlength = 0;             /* Computer length of LOB                */
    int   NeverSwap = NEVERSWAP;     /* Never endian swap if this is nonzero  */
    short LOBlength2 = 0;            /* Two-byte version of LOBlength         */
    short floatconvert = NOCONVERT;  /* Floating point conversion flag        */
    char  cLOBlength4[4];            /* Splittable version of (2+2) LOB count */
    long int LOBlength64 = 0;        /* 64-bit version of LOBlength           */
    char  FmtRevNo[2];               /* Format Revision Number of SEGY input  */
    
    /*
     * NOTE: the first element (subscript 0) of the typelens array is for
     *       type 1, the second element (subscript 1) for type 2, and so on
     */
    int   typelens[MAXTYPE] = {4, 4, 2, 4, 4, 4, 4, 1 };
    int   typelength = 0;
    short typelenwk = 0;
    
	char  progname [4096];           /* Name of *this* program                */
	
	char slash = '/';
    //	char dot   = '.';
    
    char FHtype[] = ".ofh";          /* File type for File Header file        */
    char THtype[] = ".oth";          /* File type for Trace Header file       */
    char TDtype[] = ".otd";          /* File type for Trace Data file         */
	
    unsigned char FHrec[LEN_FH+16+1];/* File header record, read in           */
    unsigned char THrec[LEN_TH+16+1];/* Trace header record, read in          */
    
    char temp[4096];                 /* Work area */
    unsigned char DataBuffer[4*MAXBUFFER+1];
    /*
	 *  Set to default debug level:
	 */
	tprint = DEBUG_LEV;
	
    /*  COPYRIGHT  */
    fprintf(stderr, "This program is strictly Copyright (c) 2013 Westheimer "
            "Energy Consultants Inc.\n"
            "All rights reserved\n\n");
    
    /*  ENDIANNESS  */
    
	/*
	 *  Test and remember the endianness of *this* machine:
	 */
	if (ENDIANNESS == BIG)
	{
		thisendian = ISBIG;
	}
	else if (ENDIANNESS == LITTLE)
	{
		thisendian = ISLITTLE;
	}
	else 
	{
		fprintf(stderr,
                "ERROR: ENDIAN format of this machine not supported (%d / %x).\n",
                endianness,endianness);
		fprintf(stderr, "[endianness first byte is %x]\n",
                *(const char *)&endianness);
		cmderr++;
	}
    
    /*
     *  If the endianness of this machine is LITTLE then correct the TH_ONE to
     *  contain a big-endian value one:
     */
    if (ENDIANNESS == LITTLE)
    {
        TH_ONE = swap_int32(TH_ONE);
    }
	
    /*  Output file pointers to NULL as initial values: */
    for (i=0; (i<MAXOUTFILES); i++)
    {
        opf[i] = (FILE *)NULL;
        fnameD[i] = -1;
    }
    
    /*  Output directory name is empty, by default: */
    alldirname[0] = '\0';
    
    /*  PROGRAM NAME  */
    
	/*
	 *  Remember the program name - the name of this program - for
	 *  debug and message printout. We edit out, from the name of
	 *  the program as invoked, any prior directory name specified:
	 */
	strcpy(temp, argv[0]);
	j = strlen(temp); 
	i = 0;
	while((j>i) && (temp[j] != slash)) 
	{
		j--;
	}
	/* If there actually was a slash in the program name, we are now pointing at
	 * it - so move forwards to point to the first character after the
	 * rightmost slash: */
	if ( temp[j] == slash ) 
	{
		j++;
	}
	k = strlen(temp); 
	strncpy(progname, &temp[j], k-j);
	/* Add a terminating string end character: */
	progname[k-j] = '\0';
	
    
    /*  COMMAND LINE PROCESSING  */
    
	/*
     *  Read in and initially process each command line parameter:
     */
    
    UseFHsamp = 0;
    UseTHsamp = 0;
    
    while ((c = getopt(argc, argv, ":n:P:B:S:E:I:X:h:r:i:o:f:t:d:D:T:F:e:O:R:vus")) != -1)
    {
        switch(c)
        {
                /* Number of output files: */
            case 'n':
                nstr = optarg;
                i = atoi(nstr);
                if ((i<1) || (i>MAXOUTFILES))
                {
                    fprintf(stderr, 
                            "Error: -n must be between 1 and %d, not %d\n",
                            MAXOUTFILES, i);
                    cmderr++;
                }
                else 
                {
                    noutputfiles = i;
                }

                break;
                
                /* Type of slicing - if any - being done by this program */
            case 'P':
                slicetype = optarg;
                /*
                 *  Verify that the type of slicing is one of t/T i/I x/X n/N
                 */
                if ((strncmp(slicetype, "x", 1)==0) || 
                    (strncmp(slicetype, "X", 1)==0))
                {
                    fprintf(stderr, "INFO:  Crossline sample extraction\n");
                    sliceform = 1;
                    noutputfiles = 1;
                }
                else if ((strncmp(slicetype, "i", 1)==0) || 
                         (strncmp(slicetype, "I", 1)==0))
                {
                    fprintf(stderr, "INFO:  Inline sample extraction\n");
                    sliceform = 2;
                    noutputfiles = 1;
                }
                else if ((strncmp(slicetype, "t", 1)==0) || 
                         (strncmp(slicetype, "T", 1)==0))
                {
                    fprintf(stderr, "INFO:  Timeline sample extraction\n");
                    sliceform = 3;
                    /*
                     *  Note that 'noutputfiles' is NOT altered here, as this
                     *  is the case when many output files may be generated at
                     *  the same time.
                     */
                }
                else if ((strncmp(slicetype, "n", 1)==0) || 
                         (strncmp(slicetype, "N", 1)==0))
                {
                    fprintf(stderr, 
                            "INFO:  No sub-extraction: all samples used\n");
                    sliceform = 0;
                    noutputfiles = 1;
                }
                else 
                {
                    fprintf(stderr, 
                            "ERROR: Invalid -P option [%s] - only x,i,t,n permitted\n", 
                            slicetype);
                    fprintf(stderr, "       Program terminates.\n");
                    exit (BAD_P_PARAM);
                }
                break;
                
                /* Displacement of INline in THrec: */
            case 'I':
                Istr = optarg;
                disp_inline = atoi(Istr);
                if ((disp_inline<0) || (disp_inline>LEN_TH))
                {
                    fprintf(stderr,"ERROR: -I must be between 0 and %d, not %d\n",
                            LEN_TH, disp_inline);
                    cmderr++;
                }
                break;
                
                /* Displacement of CROSSline in THrec: */
            case 'X':
                Xstr = optarg;
                disp_crossline = atoi(Xstr);
                if ((disp_crossline<0) || (disp_crossline>LEN_TH))
                {
                    fprintf(stderr,"ERROR: -X must be between 0 and %d, not %d\n",
                            LEN_TH, disp_crossline);
                    cmderr++;
                }
                break;
                
                /* Displacement of first sample to use: */
            case 'B':
                Fstr = optarg;
                i = atoi(Fstr);
                if ((i<0) || (i>MAXSAMPLES))
                {
                    fprintf(stderr, 
                            "ERROR: -B must be between 1 and %d, not %d\n",
                            MAXSAMPLES, i);
                    cmderr++;
                }
                else {
                    firstsample = i;
                }
                break;
                
                /* Step-size between samples to use: */
            case 'S':
                Sstr = optarg;
                i = atoi(Sstr);
                if ((i<1) || (i>MAXSAMPLES))
                {
                    fprintf(stderr, 
                            "ERROR: -S must be between 1 and %d, not %d\n",
                            MAXSAMPLES, i);
                    cmderr++;
                }
                else {
                    samplestep = i;
                }
                break;
                
                /* Input file name root: */
            case 'i':
				ifhfile = optarg;
                ithfile = ifhfile;
                itdfile = ifhfile;
                strcpy(fhnamein, ifhfile);
                /*
                 *  When specifying -i we can set all three input file names
                 *  from the -i root. This means that we have to append the
                 *  fixed file types to the root name give by the user here:
                 */
                strcpy(thnamein, ifhfile);
                strcpy(tdnamein, ifhfile);
				strcat(fhnamein, FHtype);
                strcat(thnamein, THtype);
                strcat(tdnamein, TDtype);
                break;
                
                /* Output file name root: */
            case 'o':
				ofile = optarg;
				strcpy(fnameout, ofile);
                break;
                
                /* Input file name, for file header file only: */
            case 'f':
				ifhfile = optarg;
				strcpy(fhnamein, ifhfile);
                break;
                
                /* Input file name, for trace header file only: */
            case 't':
				ithfile = optarg;
				strcpy(thnamein, ithfile);
                break;
                
                /* Input file name, for trace data only: */
            case 'd':
				itdfile = optarg;
				strcpy(tdnamein, itdfile);
                break;
                
                /* Output directory: */
            case 'D':
                odirname = optarg;
                strcpy(alldirname, odirname);
                break;
                
                /* Trace Header sequence number in line: */
            case 'h':
                THfilecount = atoi(optarg);
                fprintf(stderr, "TH Trace seq. no. in line is: %d\n",
                        THfilecount);
                THfcUSE = THfilecount;
                if (thisendian == ISLITTLE)
                {
                    THfilecount = swap_int32(THfilecount);
                }
                break;
                
                /* Trace Header sequence number in file initial value: */
            case 'r':
                THsegcount = atoi(optarg);
                THscUSE = THsegcount;
                fprintf(stderr, "TH Trace seq. no. in file starts at: %d\n",
                        THsegcount);
                if (thisendian == ISLITTLE)
                {
                    THsegcount = swap_int32(THsegcount);
                }
                if (THsegcount == 0)
                {
                    fprintf(stderr, "ERROR: -r field may not be zero\n");
                    cmderr++;
                }
                break;
                
                /* DEBUG: skip some of the Trace Header metadata output: */
            case 'e':
                ExtraTH = atoi(optarg);
                break;
                
                /* TESTING: set debug trace flags: */
            case 'T':
                tprint = atoi(optarg);
                fprintf(stderr,
                        "WARNING: trace flags (-T) not for production\n");
                break;
                
                /* Show program version number and compile date: */
            case 'v':
                fprintf(stderr, "Program Version %s %s\n", STHVERSION, STHDATE);
				fprintf(stderr, "Program Name:   %s : %s\n", progname, argv[0]);
                break;
                
                /* Use sample count as stated in Trace Header record: */
            case 'u':
                UseTHsamp = 1;
                break;
                
                /* Floating-point format of the output: */
            case 'F':
                oformat = optarg;
                break;
                
                /* TESTING only: skip data reading: */
            case 's':
                SkipReadData = 1;
                fprintf(stderr,
                        "WARNING: Data reading is skipped - not for production\n");
                break;
                
                /* Set endian value of the input data */
            case 'E':
                pin_end = optarg;
                if (NeverSwap != 0)
                {
                    fprintf(stderr, 
                            "Warning: -E option ignored - not yet supported\n");
                }
                break;
                
                /* Set endian value of the output data: */
            case 'O':
                pout_end = optarg;
                if (NeverSwap != 0)
                {
                    fprintf(stderr, 
                            "Warning: -O option ignored - not yet supported\n");
                }
                break;
                
                /* Rewrite (i.e. permit overwrite) of output files: */
            case 'R':
                rewrite = optarg;
                /* Check argument against y/Y/n/N */
                if ((strncmp(rewrite,"n",1)==0)||(strncmp(rewrite, "N", 1)==0))
                {
                    fprintf(stderr, "Existing files may NOT be overwritten\n");
                    rew = 0;
                }
                else if ((strncmp(rewrite,"n",1)==0)||(strncmp(rewrite, "N", 1)==0))
                {
                    fprintf(stderr, "Existing files CAN be overwritten\n");
                    rew = 1;
                }
                else 
                {
                    fprintf(stderr, "ERROR: -R may be Y or N not %s\n",rewrite);
                    cmderr++;
                }

                break;
                
                /* Unrecognised option: */
            case '?':
				fprintf(stderr, "ERROR: Unrecognized option: -%c\n", optopt);
				cmderr++;
                
        }
    }
    
    
    /*  VERIFY INPUT AND OUTPUT FILES  */
    
    /*
     *  Check that we have an output file, and that it can be opened:
     */
    if (ofile == (char *)NULL)
    {
        fprintf(stderr, "ERROR: No output file base (-o) has been specified\n");
        cmderr++;
    }
    else 
    {
        fprintf(stderr, "Information: output file name base is %s\n", ofile);   
    }
    
    /*
     *  Check that we have the right number of openable input files.
     */
    if (CountFilesIn == 1)
    {
        ithfile = ifhfile;
        itdfile = ifhfile;
    }
    else if (CountFilesIn == 2)
    {
        ithfile = ifhfile;
    }
    
    /*
     *  First, we check that we have at least the File Header file information,
     *  because if that does not exist then all of the run is pointless.
     *  We then check whether both of the other two files have been 
     *  specified.
     */
    if (ifhfile == (char *)NULL)
    {
        fprintf(stderr, 
                "ERROR: No input File Header file (-i or -f) specified\n");
        cmderr++;
    }
    else
    {
        /*
         *  Try to open the input File Header file:
         */
        if (tprint !=0 ) fprintf(stderr, "Opening Input File Header [%s]\n", 
                                 fhnamein);
        fhipf = fopen(fhnamein,"r");
        if (fhipf == (FILE *)NULL)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open input File Header (-i -f)  [%s]\n"
                    "       errno = %d\n", fhnamein, errno);
            cmderr++;
        }
        /* Leave the input File Header file open for the run */        
    }
    
    if (ithfile == (char *)NULL)
    {
        fprintf(stderr, 
                "ERROR: No input Trace Header file (-i or -t) specified\n");
        cmderr++;
    }
    else 
    {
        /*
         *  Try to open the input Trace Header file:
         */
        if (tprint !=0 ) fprintf(stderr, "Opening Input Trace Header [%s]\n", 
                                 thnamein);
        thipf = fopen(thnamein, "r");
        if (thipf == (FILE *)NULL)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open input Trace Header (-i -t) [%s]\n"
                    "       errno = %d\n", thnamein, errno);
            cmderr++;
        }
        /* Leave the input Trace Header file open for the run */        
    }
    
    if (itdfile == (char *)NULL)
    {
        fprintf(stderr, 
                "ERROR: No input Trace Data file (-i or -d) specified\n");
        cmderr++;
    }
    else 
    {
        /*
         *  Try to open the input Trace Data file:
         */
        if (tprint !=0 ) fprintf(stderr, "Opening Input Trace Data [%s]\n", 
                                 tdnamein);
        tdipf = fopen(tdnamein, "r");
        if (tdipf == (FILE *)NULL)
        {
            fprintf(stderr, 
                    "ERROR: Unable to open input Trace Data (-i -d)   [%s]\n"
                    "       errno = %d\n", tdnamein, errno);
            cmderr++;
        }
        /* Leave the input Trace Data file open for the run */        
    }
       
    
    if (oformat != (char *)NULL)
    {
        if ((*oformat == 'i') || (*oformat == 'I'))
        {
            fprintf(stderr, "Output will contain IBM floating-point format\n");
            floatconvert = CIBM;
        }
        else if ((*oformat == 'e') || (*oformat == 'E'))
        {
            fprintf(stderr, "Output will contain IEEE floating-point format\n");
            floatconvert = CIEEE;
        }
        else if ((*oformat == 'b') || (*oformat == 'B'))
        {
            /* In this case BOTH IBM and IEEE have been requested */
            fprintf(stderr, "Output will contain both IBM and IEEE formats\n");
            floatconvert = CBOTH;
            fprintf(stderr, "ERROR: -F b not yet supported.\n");
            cmderr++;
        }
        else {
            fprintf(stderr, "ERROR: -F parameter may be i or e and not %c\n",
                    *oformat);
            cmderr++;
        }
    }
    
    
    /*
	 ** If something went wrong, whinge and die ...
	 */
    if (cmderr)
    {
        fprintf(stderr, "Command Error (%d)\n", cmderr);
        fprintf(stderr, "\n");
        fprintf(stderr, "Usage: %s <options>\n", argv[0]);
        fprintf(stderr, "  Options:-\n");
        fprintf(stderr, "   -i <filename>   Input STH File base    [No Default]\n");
        fprintf(stderr, "   ( -i may be split into -f, -t, -d naming the three\n");
        fprintf(stderr, "     separate File Header, Trace Header, and Data files:\n");
        fprintf(stderr, "     -f <filename> Input STH File Header file\n");
        fprintf(stderr, "     -t <filename> Input STH Trace Header file\n");
        fprintf(stderr, "     -d <filename> Input STH Trace Data file )\n");
        fprintf(stderr, "   -o <filename>   Output SEG File        [No Default]\n");
		fprintf(stderr, "   -v              Show version of this program\n");
        fprintf(stderr, "   -P <x/i/t/n>    Slice Type (Optional)  [Default N]\n");
        fprintf(stderr, "   -B <number>     First Slice parameter  [Default 0]\n");
        fprintf(stderr, "   -S <number>     Second Slice parameter [Default 1]\n");
        fprintf(stderr, "   -I <number>     Displ. of INline in TH [Default 188]\n");
        fprintf(stderr, "   -X <number>     Displ. of CROSSline TH [Default 192]\n");
        fprintf(stderr, "   -h <filecount>  (Optional) Trace Header file count value\n");
        fprintf(stderr, "   -r <rec_count>  (Optional) Trace Header SEGY count value\n");
        fprintf(stderr, "   -F <i / e>      Float type convert     [Default none]\n");
        fprintf(stderr, "   -e <length>     Extra TH leng. skip    [Default 0]\n");
        if (NeverSwap == 0)
        {
            fprintf(stderr, "   -E <b / l>      Endian of input file [Default b(ig)]\n");
            fprintf(stderr, "   -O <b / l>      Endian of output file[Default b(ig)]\n");
        }
        //        fprintf(stderr, "   -T <debug>      (DEBUG ONLY) Trace   [Default 0]\n");
        fprintf(stderr, "\n");
		fprintf(stderr, "Program Version %s %s\n", STHVERSION, STHDATE);
        fprintf(stderr, "Program Name:   %s : %s\n", progname, argv[0]);
        fprintf(stderr, "\n");
		
        exit(PARAM_ERROR);
    }

    /*  INDICATE THE PARAMETER VALUES FOR THIS RUN  */
    
    /*
	 *  Tell the user what the values are of the parameters, as read and as
	 *  taken by default:
	 */
	fprintf(stderr, "\nProgram %s is being run with following options:\n\n"
            ,progname);
	fprintf(stderr, "Program Version %s %s\n", STHVERSION, STHDATE);
 	fprintf(stderr, 
            "Input file names:  %s\n"
            "                   %s\n"
            "                   %s\n", 
            fhnamein, thnamein, tdnamein);
    if (sliceform != 0)
    {
        /*
         *  This is a Slice - so lots of output files:
         */
        fprintf(stderr, "Output file names: (base) %s\n",
                fnameout);
    }
    else 
    {
        /*
         *  This is not a Slice - so only one file output:
         */
        fprintf(stderr, "Output file name:  %s\n", fnameout);
    }

    
    if (nonulls != 0)
    {
        fprintf(stderr, "Do not copy leading null characters in first chunk\n");
    }
    else 
    {
        fprintf(stderr,
                "Retain, and copy, %d leading nulls in initial chunks\n",
                FileNameMax);
    }
    
    if (WriteTwo != 0)
    {
        fprintf(stderr, "Insert 2-byte count preceding LOB\n");
    }
    if (WriteFour != 0)
    {
        fprintf(stderr, "Insert 4-byte (2+2) count preceding LOB\n");
    }
    if (Write64 != 0)
    {
        fprintf(stderr, "Insert 8-byte (64-bit) count preceding LOB\n");
    }
    if ((WriteTwo == 0) && (WriteFour == 0) & (Write64 == 0))
    {
        fprintf(stderr, "Insert no extra count preceding data LOB\n");
    }
    
    if (oformat != (char *)NULL)
    {
        if (floatconvert == CIBM)
        {
            fprintf(stderr, "Floating point output is in IBM format\n");
        }
        else if (floatconvert == CIEEE)
        {
            fprintf(stderr, "Floating point output is in IEEE format\n");
        }
    }
    
    if (THfcUSE >= 0)
    {
        fprintf(stderr, "Trace sequence number within line is %d\n",
                THfcUSE);
    }
    else
    {
        fprintf(stderr, "Trace sequence number within line taken from input\n");
    }
    if (THscUSE > 0)
    {
        fprintf(stderr, "Trace sequence number within SEGY file begins at %d\n",
                THscUSE);
    }
    else
        if (THscUSE == 0) {
            fprintf(stderr, "Trace sequence number in SEGY file starts at 1 (one)\n");
        }
        else
        {
            THscUSE = -1;
            fprintf(stderr, "Trace sequence number in SEGY file taken from input\n");
        }
    
    if (ExtraTH != 0)
    {
        fprintf(stderr, "Extra Trace Header skip of %d bytes\n", ExtraTH);
    }
    
    /* Check and display the endian indicators, if any: */
    if (pin_end != (char *)NULL)
    {
        if ((*pin_end == 'b') || (*pin_end == 'B'))
        {
            input_endian = BIG;
            fprintf(stderr,"Input file  is  Big   endian\n");
        }
        else if ((*pin_end == 'l') || (*pin_end == 'L'))
        {
            input_endian = LITTLE;
            fprintf(stderr,"Input file  is Little endian\n");
        }
        else
        {
            fprintf(stderr," ERROR: Input endian -E may be b or l not %c\n",
                    *pin_end);
            exit(BAD_INPUT_END);
        }
    }
    else
    {
        fprintf(stderr,     "Input file  is  Big   endian (default)\n");
    }
    
    if (pout_end != (char *)NULL)
    {
        if ((*pout_end == 'b') || (*pout_end == 'B'))
        {
            output_endian = BIG;
            fprintf(stderr, "Output file is  Big   endian\n");
        }
        else if ((*pout_end == 'l') || (*pout_end == 'L'))
        {
            output_endian = LITTLE;
            fprintf(stderr, "Output file is Little endian\n");
        }
        else
        {
            fprintf(stderr,"ERROR: Output endian -O may be b or l not %c\n",
                    *pout_end);
            exit(BAD_OUTPUT_END);
        }
    }
    else
    {
        fprintf(stderr,    "Output file is  Big   endian (default)\n");
    }
    
    if (NeverSwap !=0)
    {
        if ((pin_end != (char *)NULL) || (pout_end != (char *)NULL))
        {
            fprintf(stderr, "Warning: No file endian-swap will take place -\n"
                    "         Not yet supported.\n");
            /* Force defaults: */
            input_endian = BIG;
            output_endian = BIG;
        }
    }
    
    fprintf(stderr, "INline displacement in TH is    %d\n", disp_inline);
    fprintf(stderr, "CROSSline displacement in TH is %d\n", disp_crossline);
    
    if (rew==0)
    {
        fprintf(stderr,"Pre-existing output files may be overwritten\n");
    }
    else 
    {
        fprintf(stderr,"Pre-existing output files will NOT be overwritten\n");
    }

    
    /* Write one spacing line - to make the printed output look pretty :-)  */
    fprintf(stderr, "\n");
    
    /* >>> Start of main processing <<< */
    
    /*
     *  There are two top-level operations here:
     *  1)  read and record in memory the File Header information
     *  2)  read each individual Trace Header record, and for each of these
     *  3)  read the appropriate Trace Data words, and for each such word
     *      generate a file containing:
     *      a) a single copy of the File Header record,
     *      b) a single copy of a Trace Header record (adjusted), and
     *      c) one data sample word.
     *  Note that we do not know how many output SEG Y files this program is
     *  going to generate until we have read the first Trace Header record.
     *
     *  But here we start with reading the File Header information, as given
     *  by the STH database query, and constructing a correctly-formatted SEGY
     *  File Header + Binary Header record.
     */
    
    
    /*  Part One : FILE HEADER  */
    
    /*
     *  Open and Read the File Header input:
     */
    l = fread(FHrec,sizeof(unsigned char),LEN_FH,fhipf);
    iFHlength = iFHlength + l;   /*  Count length of record read  */
    if (l != LEN_FH)
    {
        fprintf(stderr,
                "ERROR: File Header record not read successfully, l=%d\n"
                "       errno = %d\n", l, errno);
        fprintf(stderr,"       Program terminates.\n");
        exit(BAD_FILE_HEADER);
    }
    
    /*
     *  Remember the relevant fields from this File Header.
     *  First the expected number of samples per trace:
     */
    nsamples = 0;
    memcpy(&nsamplesFH,&FHrec[(PFH_SAMPTHISR) - (PFH_START)],LFH_SAMPTHISR);
    if ((thisendian == ISLITTLE) && (input_endian == BIG))
    {
        nsamplesFH = swap_int16(nsamplesFH);
    }
    /*
     *  Look at the Fixed Length Trace Flag to determine whether we should
     *  be using the sample count from the File Header, or we should use
     *  the (possibly different) sample count from the Trace Header:
     */
    memcpy(&UseFHsamp,&FHrec[(PFH_FLTRFLG) - (PFH_START)],LFH_FLTRFLG);
    memcpy(&FmtRevNo,&FHrec[(PFH_SEGYREVNO) - (PFH_START)],LFH_SEGYREVNO);
    if ((FmtRevNo[0] == '\0') && (FmtRevNo[1] == '\0') && (UseTHsamp == 0))
    {
        UseFHsamp = 1;
        UseTHsamp = 0;
    }
    if (UseFHsamp == 0)
    {
        UseTHsamp = 1;
    }
    else 
    {
        nsamples = nsamplesFH;
    }
    
    /*
     *  At this point we have only one of UseFHsamp and UseTHsamp as non-zero,
     *  and if UseFHsamp is non-zero, then nsamplesFH contains the expected
     *  count of samples per trace for all trace records in this extract, as
     *  does nsamples.
     */

    /*
     *  Get the data sample format code, and compute the type length for this
     *  data:
     */
    memcpy(&typelenwk,&FHrec[(PFH_DATSAMPFC) - (PFH_START)],LFH_DATSAMPFC);
    if ((thisendian == ISLITTLE) && (input_endian == BIG))
    {
        typelenwk = swap_int16(typelenwk);
    }
    if ((typelenwk >0) & (typelenwk <= MAXTYPE))
    {
        typelength = typelens[typelenwk-1];
    }
    else 
    {
        /*
         *  The data type specified in the FH record is not, strictly, valid, 
         *  We assume the length of each sample is 4 bytes, and warn the user:
         */
        typelength = 4;
        fprintf(stderr,
                "WARNING: Type length assumed to be 4, type %d specified in FH\n",
                typelenwk);
    }
    datatype = typelenwk;
    
    /*
     *   Check the datatype as recorded in the header record against the
     *   conversion that is requested by the user. If these are the same type 
     *   then there is no conversion to be performed:
     */
    if ((datatype == TYPEIBM32) && (floatconvert == CIBM))
    {
        floatconvert = NOCONVERT;
    }
    else if ((datatype == TYPEIEEE32) && (floatconvert == CIEEE))
    {
        floatconvert = NOCONVERT;
    }
    
    /*  
     *  Construct, ready to write, the File Header + Binary Header of the output:
     *  Firstly, we have to flip the bit-ordering if the input and the
     *  output are different:
     */
    if ((NeverSwap == 0) && 
        (((input_endian == BIG) && (output_endian == LITTLE)) ||
         ((input_endian == LITTLE) && (output_endian == BIG))))
    {
        for (j=0;j<LEN_FH_4;j=j+4)
        {
            cc = FHrec[j];
            FHrec[j] = FHrec[j+3];
            FHrec[j+3] = cc;
            cc = FHrec[j+2];
            FHrec[j+2] = FHrec[j+1];
            FHrec[j+1] = cc;
        }
    }
    
    /*
     *  If there are any subsidiary file headers, this is where to read (and
     *  write) them. Note that the length of the subsidiary (auxilary) file
     *  headers have a shorter length - as we have included the binary header
     *  in with the first file header.
     */
    memcpy (&nauxfh, &FHrec[(PFH_NETFHREC) - (PFH_START)], LFH_NETFHREC);
    if ((thisendian == ISLITTLE) && (input_endian == BIG))
    {
        nauxfh = swap_int16(nauxfh);
    }
    fprintf(stderr, "Number of Auxiliary File Header records = %d\n", nauxfh);
    
    /*
     *  Verify that we have reached the end of the input File Header file.
     *  We could do this by doing one more read, ensuring that the length read 
     *  is zero, and verifying that the feof flag is set - but for the moment
     *  we do not have that code present.
     */
//    maxnaux = nauxfh;
    
    /*
     *  This program does NOT support auxillary input File Header records:
     */
    if (nauxfh != 0)
    {
        fprintf(stderr, "ERROR: Auxilliary File Header input not supported\n"
                "       Program terminates.\n");
        exit (BAD_AUX_FHEAD);
    }
    
    /*
     *  At this point we have read and remembered the whole of the first File
     *  Header record (with Binary Header). To check that we are the end of
     *  the File Header input file we perform one more read, and verify that
     *  we have both (a) read nothing, and also (b) we are at end-of-file:
     */
    
    l = fread(FHrec,1,FHSIZE,fhipf);
    /* Do NOT count this read, in the input count, as it should be zero */
    if (l != 0)
    {
        fprintf(stderr, "ERROR: Extra File Header information presented - \n"
                "       of length %d.\n"
                "       errno = %d\n"
                "       Program terminates.\n", l, errno);
        exit(BAD_EXTRA_FH1);
    }
    l = feof(fhipf);
    if (l == 0)
    {
        fprintf(stderr, "ERROR: Extra File Header information presented -\n"
                "       of unknown length.\n"
                "       errno = %d\n"
                "       Program terminates.\n", errno);
        exit(BAD_EXTRA_FH2);
    }
    else 
    {
        fprintf(stderr, "All File Header input processed successfully\n");
    }
    
    /*
     *  Close the File Header input file:
     */
    tfclose(fhipf);
    fhipf = (FILE *)NULL;
    if (tprint != 0)
    {
        fprintf(stderr, "File Header output bytes:  %d\n", FHlength);
    }

    /*  Part two: DATA  */
    
    /*
     *  This is a loop, reading first the trace header, then the corresponding
     *  data for that header, and writing these to the output. The loop ends
     *  when there is no more input from the Trace Header input file.
     *  The data count in the very first trace header is used to determint the
     *  number of output files that we need to open. Each output file is primed
     *  with a copy of the (remembered) Trace Header record.
     */
    while (TraceEnd == 0)
    {   /*  MAIN DATA LOOP START  */
        
        
        /*  Read in the next Trace Header record: */
        l = fread(THrec,1,LEN_TH+ExtraTH,thipf);
        iTHlength = iTHlength + l;
                
        /*
         *  Check whether we have read the correct amount - if not, then we
         *  may be at the end of the Trace Header input file:
         */
        if (l != LEN_TH+ExtraTH)
        {
            /*
             * Indicate, no matter what, that we must not read any more of
             * the input Trace Header file:
             */
            TraceEnd = 1;
            if (l == 0)
            {
                /*
                 *  The amount read in was zero - if we are at feof, then all
                 *  is well. If, however, we are not at feof, then there is
                 *  something wrong:
                 */
                i = feof(thipf);
                if (i == 0)
                {
                    fprintf(stderr, "ERROR: Trace Header input file not "
                            "correctly terminated\n"
                            "       Error is after %d records\n"
                            "       Program terminates.\n", TraceCount);
                    exit(BAD_EOF_ITH);
                }
                
                /*
                 *  We have reached end of file on the TH file - we *should* 
                 *  also be at end of file on the data file - check that this is
                 *  the case, and if not warn the user:
                 */
                l = fread(&TDDataLength, 1, 2, tdipf);
                if (l != 0)
                {
                    /* problem */
                    fprintf(stderr,
                            "WARNING: After processing all %d Trace Headers\n"
                            "         there is still some data unprocessed\n"
                            "         errno = %d\n", TraceCount, errno);
                    fprintf(stderr,
                            "         Program terminates\n");
                    /*
                     *  We could un-comment the following exit statement - but 
                     *  since the only thing this program now does (in any case)
                     *  is to print the trailing messages and stop, we allow
                     *  flow to continue and for that to happen.
                     *  IF we ever add anything further to this program, 
                     *  following the main data-processing loop, then we MUST
                     *  un-comment this exit:
                     */
                    //                    exit(BAD_MISSING_DATA);
                }
                else 
                {
                    /*
                     *  We did not read anything from the data file - which is
                     *  good - but now check that we are at end of file:
                     */
                    l = feof(tdipf);
                    if (l == 0)
                    {
                        /*
                         *  Ah - a problem - we are not, strictly, at end of
                         *  file on the data file, even though we know there is
                         *  nothing else to read from it. We know that we have
                         *  actually processed all the incoming data - so just
                         *  warn the user that something obscure is amis:
                         */
                        fprintf(stderr,
                                "WARNING: End-of-file not correctly detected on data file:\n"
                                "         All data appears to have been processed\n");
                    }
                    else 
                    {
                        /*
                         *  This is good - both the TH and the TD files are at
                         *  end-of-file, and both have been completely read.
                         */
                        fprintf(stderr, "Both Trace Header and Trace data "
                                "files processed completely.\n");
                    }
                }
            }
        }
        else 
        {
            /*
             *  The Trace Header record was successfully read. Save the 
             *  relevant information from this record. First, we determine
             *  whether we should be using this Trace Header record for the
             *  count of number of samples: if so, get that count...
             */
            TraceCount++;  /*  Count number of Trace Headers read  */
//            fprintf(stderr,"DEBUG: we have read %d TH records\n",TraceCount);
            
            memcpy(&nsamplesTH, &THrec[(PTH_NOSAMPTR) - (PTH_START)],
                   LTH_NOSAMPTR);
            memcpy(&ThisIn,    &THrec[disp_inline],    len_inline);
            memcpy(&ThisCross, &THrec[disp_crossline], len_crossline);  
            if (thisendian == ISLITTLE)
            {
                ThisIn = swap_int32(ThisIn);
                ThisCross = swap_int32(ThisCross);
            }
            
            /*
             *  If this is the first Trace Header record then we have, for the
             *  first time, information as to how many actual output files we are
             *  going to be generating. This number is in the "nosamptr" field
             *  (number of samples in this trace) +115-116.
             *  Open the output files, indicating this to the user:
             */
            
            usensamplesTH = nsamplesTH;
            if (usensamplesTH>MAXOUTFILES)
            {
                /*
                 *  There are too many samples to create all the files at the
                 *  same time, so set an upper limit. NOTE that this should, in
                 *  production, also raise an error message:
                 */
                usensamplesTH = MAXOUTFILES;
            }
            if (usensamplesTH>noutputfiles)
            {
                /*
                 *  There are more samples in the input than the user has asked
                 *  for on the command line. NOTE that in production this could
                 *  also raise a warning/information message:
                 */
                usensamplesTH = noutputfiles;
            }
            if ((opf[0] == (FILE *)NULL) && ((sliceform == 3) || (sliceform == 0)))
            {
                /*
                 *  This is the first TH record to be read, so we now have to
                 *  open the output file or files. The number - and name - of 
                 *  the files to open depends upon the slice type.
                 *  -P n  (Normal) There is no slicing, so only one output file
                 *        is required. This is the default for this program.
                 *  -P x  (Crossline) There will be a series of output files,
                 *        a different one for each Inline.  
                 *  -P i  (Inline) There will be a series of output files, a
                 *        different one for each Crossline. 
                 *  -P t  (Timeline) There are a number of output files, one
                 *        for each timeslice being processed. The number opened
                 *        is the minimum of (a) the number of data samples in
                 *        this first point, (b) the maximum number of files that
                 *        can be opened at once (in the value MAXOUTFILES).
                 */
                if (sliceform == 0)
                {
                    /* There is NO slicing - only one output file: */
                    /*
                     *  Set the only output file name to be the base name, 
                     *  within the -d specified directory (if any):
                     */
                    if (odirname != (char *)NULL)
                    {
                        strcpy(&fnameoutD[0][0], odirname);
                        strcat(&fnameoutD[0][0], fnameout);
                    }
                    else 
                    {
                        strcpy(&fnameoutD[0][0], fnameout);
                    }

                    usensamplesTH = 1;
                    
                    /* Open the file: */
                    currentfile = 0;
                    /* Version 0.52 onwards: Do we allow overwrite of an
                     * existing file? If so, simply open the file for output,
                     * but if not, test whether the file exists, and simply
                     * return to caller:
                     */
                    if (rew!=0)
                    {
                        opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "r");
                        if (opf[currentfile] != (FILE *)NULL)
                        {
                            /* The file already exists - quit and return to caller */
                            fprintf(stderr,
                                    "INFO:  Output file already exists - OK\n");
                            goto ProgramEnd;
                        }
                        /* Ensure that the test open leaves behind no trace: */
                        opf[currentfile] = (FILE *)NULL;
                    }
                    opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "w");
                    if (opf[currentfile] == (FILE *)NULL)
                    {
                        fprintf(stderr,
                                "ERROR: Unable to open output (Noslice) file [%d] %s\n"
                                "       errno = %d\n"
                                "       Program terminates.\n", currentfile, 
                                &fnameoutD[currentfile][0], errno);
                        exit(BAD_OUTPUT_OPEN);
                    }
                    else 
                    {
                        fprintf(stderr,
                                "INFO:  Opened output (Noslice) file [%d] %s\n",
                                currentfile, &fnameoutD[currentfile][0]);
                    }
                    currentfile = 0;
                    /*
                     *  Write the FH record to this output file:
                     */
                    FHwrite(&FHrec[0], &FHlength, opf[currentfile], 
                            &fnameoutD[currentfile][0]);
                }
                else 
                {
                    /* There is TIME slicing - several simultaneous output files */
                    for (currentfile=0;(currentfile<usensamplesTH);currentfile++)
                    {
                        if (opf[currentfile] == (FILE *)NULL)
                        {
                            /* Construct file name: */
                            if (currentfile==0)
                            {
                                fnameD[currentfile] = firstsample;
                            }
                            else
                            {
                                fnameD[currentfile] = fnameD[currentfile-1] + samplestep;
                            }
                            tstring = &work16[0];
                            if (odirname != (char *)NULL)
                            {
                                strcpy(&fnameoutD[currentfile][0], odirname);
                                strcat(&fnameoutD[currentfile][0], fnameout);
                            }
                            else 
                            {
                                strcpy(&fnameoutD[currentfile][0], fnameout);
                            }

                            if ((fnameD[currentfile] < 0) || (fnameD[currentfile] > 99999))
                            {
                                fprintf(stderr,"ERROR: Timeline number is outside range [%d]\n"
                                        "       Must be between 0 and 99999\n"
                                        "       Program terminates.\n",
                                        fnameD[currentfile]);
                                exit(BAD_TIMELINE);
                            }
                            sprintf(tstring, "/tline/T%05d", fnameD[currentfile]);
                            strcat (&fnameoutD[currentfile][0],tstring);
                            /* Open file "currentfile": */
                            if (rew != 0)
                            {
                                opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "r" );
                                if (opf[currentfile] != (FILE *)NULL)
                                {
                                    fprintf(stderr, "INFO:  Timeslice file %s already exists\n",
                                            &fnameoutD[currentfile][0]);
                                    tfclose(opf[currentfile]);
                                    opf[currentfile] = (FILE *)NULL;
                                    goto TlineFHOpen;
                                }
                            }
                            opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "w" );
                            if (opf[currentfile] == (FILE *)NULL)
                            {
                                fprintf(stderr,
                                    "ERROR: Unable to open output (Timeslice) file [%d] %s\n"
                                    "       errno = %d\n"    
                                    "       Program terminates.\n", currentfile, 
                                    &fnameoutD[currentfile][0], errno);
                                exit(BAD_OUTPUT_OPEN);
                            }
                            else 
                            {
                                fprintf(stderr,
                                    "INFO:  Opened output (Timeslice) file [%d] %s\n",
                                    currentfile, &fnameoutD[currentfile][0]);
                            }
                            /*
                             *  Write the FH record to this output file:
                             */
                            FHwrite(&FHrec[0], &FHlength, opf[currentfile], 
                                    &fnameoutD[currentfile][0]);
                        TlineFHOpen:;
                        } 
                    }
                }
            }
            else if (sliceform == 1)
            { 
                /* Crossline. If the output file is not open OR if this is a
                 * different Crossline from the previous one, open a new output
                 * file:
                 */
                if (ThisCross != PrevCross)
                { 
                    tfclose(opf[0]);
                    opf[0] = (FILE *)NULL; 
                    PrevCross = ThisCross;
                } 
                if (opf[0] == (FILE *)NULL)
                { 
                    /* Construct the file name: */
                    currentfile = 0;
                    usensamplesTH = 1;
                    tstring = &work16[0];
                    if (odirname != (char *)NULL)
                    {
                        strcpy(&fnameoutD[currentfile][0], odirname);
                        strcat(&fnameoutD[currentfile][0], fnameout);
                    }
                    else 
                    {
                        strcpy(&fnameoutD[currentfile][0], fnameout);
                    }

                    if ((ThisCross < 0) || (ThisCross > 99999))
                    {
                        fprintf(stderr,"ERROR: Crossline number is outside range [%d]\n"
                                "       Must be between 0 and 99999\n"
                                "       Program terminates.\n",
                                ThisCross);
                        exit(BAD_CROSSLINE);
                    }
                    sprintf(tstring, "/xline/X%05d", ThisCross);
                    strcat (&fnameoutD[currentfile][0],tstring);
                    
                    /* Open the file: */
                    /* Version 0.52 onwards: Do we allow overwrite of an exist-
                     * ing file? If so, simply open for write. If not, then
                     * check whether the output file already exists. If it
                     * does, skip the open (with an INFO message), and also
                     * skip the writing to that file. We do, though, have to
                     * read all the input, none the less:
                     */
                    if (rew != 0)
                    {
                        opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "r" );
                        if (opf[currentfile] != (FILE *)NULL)
                        {
                            /* The output file already exists - BUT we are NOT
                             * permitted to overwrite it. So close the file, and
                             * set the pointer to it to be NULL so that we do
                             * not attempt to write to this file:
                             */
                            tfclose(opf[currentfile]);
                            opf[currentfile] = (FILE *)NULL;
                            fprintf(stderr,"INFO:  Crossline File %s already exists\n", 
                                    &fnameoutD[currentfile][0]);
                            goto THfileIsOpen;
                        }
                    }
                    opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "w" );
                    if (opf[currentfile] == (FILE *)NULL)
                    {
                        fprintf(stderr,
                                "ERROR: Unable to open output (Crossline) file [%d] %s\n"
                                "       errno = %d\n"
                                "       Program terminates.\n", currentfile, 
                                &fnameoutD[currentfile][0], errno);
                        exit(BAD_OUTPUT_OPEN);
                    } 
                    else 
                    { 
                        fprintf(stderr,
                                "INFO:  Opened output (Crossline) file [%d] %s\n",
                                currentfile, &fnameoutD[currentfile][0]);
                    } 
                    currentfile = 0;
                    /*
                     *  Write the FH record to this output file:
                     */
                    FHwrite(&FHrec[0], &FHlength, opf[currentfile], 
                            &fnameoutD[currentfile][0]);
                } 
            } 
            else if (sliceform == 2)
            { 
                /* Inline. If the output file is not open OR if this is a
                 * different INline from the previous one, open a new output
                 * file:
                 */
                if (ThisIn != PrevIn)
                { 
                    tfclose(opf[0]);
                    opf[0] = (FILE *)NULL; 
                    PrevIn = ThisIn;
                } 
                if (opf[0] == (FILE *)NULL)
                { 
                    /* Construct the file name: */
                    currentfile = 0;
                    usensamplesTH = 1;
                    tstring = &work16[0];
                    if (odirname != (char *)NULL)
                    {
                        strcpy(&fnameoutD[currentfile][0], odirname);
                        strcat(&fnameoutD[currentfile][0], fnameout);
                    }
                    else 
                    {
                        strcpy(&fnameoutD[currentfile][0], fnameout);
                    }

                    if ((ThisIn < 0) || (ThisIn > 99999))
                    {
                        fprintf(stderr,"ERROR: Inline number is outside range [%d]\n"
                                "       Must be between 0 and 99999\n"
                                "       Program terminates.\n",
                                ThisIn);
                        exit(BAD_INLINE);
                    }
                    sprintf(tstring, "/iline/I%05d", ThisIn);
                    strcat (&fnameoutD[currentfile][0],tstring);
                    
                    /* Open the file: */
                    /* Version 0.52 onwards: Do we allow overwrite of an exist-
                     * ing file? If so, simply open for write. If not, then
                     * check whether the output file already exists. If it
                     * does, skip the open (with an INFO message), and also
                     * skip the writing to that file. We do, though, have to
                     * read all the input, none the less:
                     */
                    if (rew != 0)
                    {
                        opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "r" );
                        if (opf[currentfile] != (FILE *)NULL)
                        {
                            /* The output file already exists - BUT we are NOT
                             * permitted to overwrite it. So close the file, and
                             * set the pointer to it to be NULL so that we do
                             * not attempt to write to this file:
                             */
                            tfclose(opf[currentfile]);
                            opf[currentfile] = (FILE *)NULL;
                            fprintf(stderr,"INFO:  Inline File %s already exists\n", 
                                    &fnameoutD[currentfile][0]);
                            goto THfileIsOpen;
                        }
                    }
                    opf[currentfile] = fopen ( &fnameoutD[currentfile][0], "w" );
                    if (opf[currentfile] == (FILE *)NULL)
                    { 
                        fprintf(stderr,
                                "ERROR: Unable to open output (Inline) file [%d] %s\n"
                                "       errno = %d\n"
                                "       Program terminates.\n", currentfile, 
                                &fnameoutD[currentfile][0], errno);
                        exit(BAD_OUTPUT_OPEN);
                    } 
                    else 
                    { 
                        fprintf(stderr,
                                "INFO:  Opened output (Inline) file [%d] %s\n",
                                currentfile, &fnameoutD[currentfile][0]);
                    } 
                
                    currentfile = 0;
                    /*
                     *  Write the FH record to this output file:
                     */
                    FHwrite(&FHrec[0], &FHlength, opf[currentfile], 
                            &fnameoutD[currentfile][0]);
                } 
            } 
            
        THfileIsOpen:
            if ((opf[0] == (FILE *)NULL) && (sliceform == 3))
            {
                fprintf(stderr, "INFO:  Number of Time samples %d [%d]\n", 
                        nsamplesTH, usensamplesTH);
            }
                        
            if (thisendian == ISLITTLE)
            {
                nsamplesTH = swap_int16(nsamplesTH);
            }
            if (UseTHsamp != 0)
            {
                nsamples = nsamplesTH;
            }

            /*
             *  Remember the count of samples (a) used, (b) according to FH 
             *  record, and (c) according to TH records:
             */
            TotalSamples = TotalSamples + nsamples;
            TotalSamplesFH = TotalSamplesFH + nsamplesFH;
            TotalSamplesTH = TotalSamplesTH + nsamplesTH;
            
            /*
             *  If we are modifying the first two fields in the Trace Header,
             *  here is the place to do it:
             */
            if (THfcUSE >= 0)
            {
                /* NOTE: this field value does NOT change (hence comment out) */
                //                THfilecount = swap_int32(THfcUSE);
                //                THfcUSE++;
                memcpy(&THrec[0],&THfilecount,4);
            }
            /* 
             *  Note that if THfcUSE is negative, then we do not alter the input
             *  value, but leave the buffer untouched
             */
            
            if (THscUSE >= 0)
            {
                /* NOTE: but this field DOES change in value */
                THsegcount = swap_int32(THscUSE);
                THscUSE++;
                memcpy(&THrec[4],&THsegcount,4);
            }
            /*
             *  Note that if THscUSE is negative, then we do not alter the input
             *  value, but leave the buffer untouched
             */
            
            /*
             *  Now write the Trace Header record to the SEGY output files, and
             *  count the amount of data written:
             *  If we need to endian-flip the buffer, do so now:
             */
            i = LEN_TH_4;
            if ((NeverSwap == 0) && 
                (((input_endian == BIG) && (output_endian == LITTLE)) ||
                 ((input_endian == LITTLE) && (output_endian == BIG))))
            {
                for (j=0;j<i;j=j+4)
                {
                    cc = THrec[j];
                    THrec[j] = THrec[j+3];
                    THrec[j+3] = cc;
                    cc = THrec[j+2];
                    THrec[j+2] = THrec[j+1];
                    THrec[j+1] = cc;
                }
            }

            /*
             *  If this is a timeslice, change the number of data items in
             *  this Trace Header record to be one:
             */
            if (sliceform == 3)
            {
                memcpy(&THrec[(PTH_NOSAMPTR) - (PTH_START)], &TH_ONE,
                       LTH_NOSAMPTR);
            }
            else 
            {
                usensamplesTH = 1;
            }

            
            for (currentfile=0; (currentfile<usensamplesTH); currentfile++)
            {
                /*
                 *  Write the Trace Header record:
                 *  Only if the output file is open:
                 */
                if (opf[currentfile] != (FILE *)NULL)
                {
                    l = fwrite(THrec, 1, LEN_TH, opf[currentfile]);
                    if (l != LEN_TH)
                    {
                        fprintf(stderr,
                                "ERROR: Trace Header record not complete - length %d\n"
                                "       errno = %d\n", l, errno);
                        fprintf(stderr, "       File [%d] %s incomplete\n", 
                                currentfile, fnameoutD[currentfile]);
                        fprintf(stderr, "       Program terminates.\n");
                        exit(BAD_FH_WRITE1);
                    }
                }
            }
            
            THlength = THlength + LEN_TH; /* Count length of record written */
            
            /*
             *  We now know how much data we expect from the Trace Data input
             *  file. Read in this much data, together with the record
             *  prefix. The length of the data record to read in is...
             *     typelength * nsamples
             */
            
            /*  ASSUME that we get all the chunks together - i.e. that this
             *  program does NOT have to de-chunk....
             *  ... actually, that appears to be wrong, and we *do* have to
             *  de-chunk, by reading slices of data, and recomposing them into
             *  the slabs of data. Note that the slabs of data we write in this
             *  way do NOT have a preceding four-byte count word, but MAY have
             *  a preceding 64-bit LOB count (this has still to be decided in
             *  versions beyond 0.31)
             */
            
            /*
             *  Set the dechunking counters to the start of the first chunk in
             *  a set
             */
            chunkstart = 1;
            sampthisset = nsamples;
            
            if (SkipReadData == 0)
            {
                /*
                 *  Design for version 0.35:
                 *  B: are there any more samples expected for this record?
                 *     if NO, go to A:
                 *  read two-byte length
                 *  set skip length to 2
                 *  is this the first chunk in the set?
                 *     if NO, go to C
                 *     compute LOB prefix(es)
                 *     set skip length to 18
                 *  C: 
                 *  read remainder of this chunk
                 *  compute length of output to write, bearing in mind (a)
                 *  whether to skip 16 of the 18 bytes, and (b) whether we
                 *  are using (1) two-byte or (2) eight-byte or (3) no
                 *  preceding length field.
                 *  Write the length field(s) (if needed, and this is the first
                 *  chunk of the set)
                 *  Write the rest of the chunk that we have read
                 *  Count the number of samples written, and used from this
                 *  chunk, and still expected from future chunks in this set
                 *  go to B
                 *  A:
                 */
                while (sampthisset > 0) /* B: */
                {
                    /*
                     *  We have to read in just two bytes from the data file
                     *  to determine the length of the remainder of the data
                     *  record:
                     */
                    l = fread(&TDDataLength, 1, 2, tdipf);
                    /*
                     *  Check whether this record was correctly read:
                     */
                    if (l != 2)
                    {
                        //                        TraceEnd = 1; /*  Set end of large copy loop  */
                        fprintf(stderr, "ERROR: END detected in reading data length\n"
                                "       record %d bytes expected %d but read only %d\n"
                                "       Program terminates.\n",
                                TraceCount, 2, l);
                        exit (BAD_DATA_READ);
                    }
                    m = TDDataLength; /*  and save for later - to output  */
                    if (thisendian == ISLITTLE)
                    {
                        m = swap_int16(m);
                    }
                    ReadLength = m;
                    //                    RecordLength = m + 2;
                    if (ReadLength < 0)
                    {
                        fprintf(stderr, "ERROR: record %d length calculated %d\n"
                                "       Program terminates\n",
                                TraceCount, ReadLength);
                        exit(BAD_DATA_LENGTH);
                    }
                    /*
                     *  Check whether this record was correctly read:
                     */
//                    if (l != 2)
//                    {
                        //                        TraceEnd = 1; /*  Set end of large copy loop  */
//                        fprintf(stderr, "ERROR: END detected in reading data length\n"
//                                "       record %d bytes expected %d but read only %d\n"
//                                "       Program terminates.\n",
//                                TraceCount, 2, l);
//                        exit (BAD_DATA_READ);
//                    }
                    
                    /*
                     *   We are happy that this length has been correctly read.
                     */
                    skiplength = 2;
                    if (chunkstart != 0)
                    {
                        /*
                         *  If we are skipping the nulls at the start of the
                         *  first chunk, then indicate that here:
                         */
                        if (nonulls != 0)
                        {
                            skiplength = skiplength + FileNameMax;
                        }
                        /*
                         *  Compute the LOB length here:
                         */
                        LOBlength = nsamples * typelength;
                        LOBlength2 = LOBlength;
                        sn = LOBlength - 2;
                        LOBlength64 = LOBlength;
                        /*
                         *  Convert these lengths to big endian:
                         */
                        if (thisendian == ISLITTLE)
                        {
                            LOBlength = swap_int16(LOBlength);
                            LOBlength2 = swap_int32(LOBlength2);
                            LOBlength64 = swap_double(LOBlength64);
                            sn = swap_int16(sn);
                        }
                        
                        memcpy(&cLOBlength4,&LOBlength2,2);
                        sn = LOBlength - 2;
                        memcpy(&cLOBlength4[2],&sn,2);
                    }
                    /* C: */
                    /*
                     *  Get the rest of this chunk:
                     */
                    l = fread(DataBuffer, 1, ReadLength, tdipf);
                    WriteLength = ReadLength;
                    iTDlength = iTDlength + l;  /*  Remember data length read  */
                    /*
                     *  Check whether this chunk-end was correctly read:
                     */
                    if (l != ReadLength)
                    {
                        //                        TraceEnd = 1; /*  Set end of large copy loop  */
                        fprintf(stderr,
                                "ERROR: END detected in reading data\n"
                                "       Length expected %d bytes, but read %d bytes\n"
                                "       Record number %d\n"
                                "       (Input lengths  %d %d %d)\n"
                                "       (Output lengths %d %d %d)\n"
                                "       errno = %d\n"
                                "       Program terminates\n",
                                ReadLength, l, TraceCount,
                                iFHlength, iTHlength, iTDlength, 
                                FHlength,  THlength,  TDlength, errno);
                        exit (BAD_DATA_READ2);
                    }
                    
                    /*
                     *  Indicate we are no longer in the first chunk: 
                     */
                    chunkstart = 0;
                    
                    /*
                     *   Write chunk data:
                     */
                    WriteLength = WriteLength - skiplength;
                    /*
                     *  Since there was a two-byte length, it is followed by a
                     *  second two-byte length, which we skip:
                     */
                    skiplength++;  
                    /*
                     *  We are now about to write the chunk data... but if there
                     *  is floating-point conversion to perform, this is where
                     *  it must take place. The number of 4-byte fields to
                     *  convert is (WriteLength/4) - and this should divide
                     *  exactly, with no remainder. If there *is* a remainder 
                     *  then we have a problem, kids!
                     *  The conversion is done from DataBuffer to DataBuffer,
                     *  without using any other long buffer.
                     *  If this is a situation where we are NOT going to be
                     *  writing any output, skip this computationally expensive
                     *  step:
                     */
                    if (opf[currentfile] != (FILE *)NULL)
                    {
                        if (floatconvert != NOCONVERT)
                        {
                            j = WriteLength>>2;
                            if (floatconvert == CIBM)
                            {
                                ieee2ibm(&DataBuffer[skiplength-1], &DataBuffer[skiplength-1], j);
                            }
                            else if (floatconvert == CIEEE)
                            {
                            ibm2ieee(&DataBuffer[skiplength-1], &DataBuffer[skiplength-1], j);
                            }
                        }
                    /*
                     *  The data to be written may have to be endian-swapped -
                     *  if so, do that here:
                     */
                        if ((NeverSwap == 0) && 
                            (((thisendian == BIG) && (output_endian == LITTLE)) ||
                            ((thisendian == LITTLE ) && (output_endian == BIG))))
                        {
                            for (j=0;j<WriteLength;j=j+4)
                            {
                                i=skiplength-1+j;
                                w4 = swap_single((uint32_t)DataBuffer[i]);
                                memcpy((void *)&DataBuffer[i],pw4,4);
                            }
                        }
                    }
                    
                    if (sliceform!=3)
                    {
                        currentfile = 0;
                        /* Write this record only if the output file is open: */
                        if (opf[currentfile] != (FILE *)NULL)
                        {
                            l = fwrite(&DataBuffer[skiplength-1],1, WriteLength,
                                       opf[currentfile]);
                                        
                            /*
                            *  Check this was written correctly:
                            */
                            if (l != WriteLength)
                            {
                                fprintf(stderr, "ERROR: Problem in writing record %d\n"
                                    "       Tried to write %d bytes, but wrote %d bytes\n"
                                    "       errno = %d\n"    
                                    "       Program terminating",
                                    TraceCount, WriteLength, l, errno);
                                exit(BAD_DATA_WRITE);
                            }
                        }
                    }
                    else if (sliceform==3) 
                    {
                        for (currentfile=0; (currentfile<usensamplesTH); currentfile++)
                        {
                            if (opf[currentfile] != (FILE *)NULL)
                            {
                                /* The amount to write depends upon the length
                                 * of the sample type (1 or 2 or 4):
                                 */
                                WriteLength = typelength;
                                l = fwrite(&DataBuffer[skiplength-1+4*currentfile],
                                           1, WriteLength, opf[currentfile]);
                                if (l != WriteLength)
                                {
                                    fprintf(stderr, "ERROR: Problem in writing Timeslice record %d\n"
                                        "       Tried to write %d bytes, but wrote %d bytes\n"
                                        "       errno = %d\n"    
                                        "       Program terminating",
                                        TraceCount, WriteLength, l, errno);
                                    exit(BAD_DATA_WRITE);
                                }
                            }
                        }
                    }
                    else
                    {
                        fprintf(stderr, "ERROR: Unrecognised slice form [%d]\n",sliceform);
                        exit (BAD_SLICE_FORM);
                    }
                    
                    /* 
                     *  Remember data amount written:
                     */
                    TDlength = TDlength + WriteLength;  
                    
                    /*
                     *  Count for samples written and still expected:
                     */
                    n = (WriteLength + skiplength -2) / typelength;
                    sampthisset = sampthisset - n;
                }
                /*  END OF chunk  */
            }   /*  End of SkipReadData */
        }  /* End of successful Trace Header read */
    }   /*  MAIN DATA LOOP END ... End of processing one Trace Header + Data */
    
    
    /*  TIDY UP AND FINISH EXECUTION  */
    
ProgramEnd:    
    /*
     *  The program has finished processing.
     *  Display information to the user, close the files, and exit:
     */
    if (tprint != 0)
    {
        fprintf(stderr, "DEBUG: TotalSamples %d FH %d TH %d\n", TotalSamples,
                TotalSamplesFH, TotalSamplesTH);
    }
    fprintf(stderr, "\nNumber of Traces written:  %d\n\n", TraceCount);
    fprintf(stderr, "File Header OUTput bytes:  %d\n",     FHlength);
    fprintf(stderr, "Trace Header OUTput bytes: %d\n",     THlength);
    fprintf(stderr, "Data OUTput bytes:         %d\n\n",   TDlength);
    fprintf(stderr, "File Header INput bytes:   %d\n",     iFHlength);
    fprintf(stderr, "Trace Header INput bytes:  %d\n",     iTHlength);
    fprintf(stderr, "Data INput bytes:          %d\n\n",   iTDlength);
    
    /* 
     *  Close files:
     */
    if ( strcmp(ofile, "stdout") != 0 )
    {
        for (currentfile=0; (currentfile<MAXOUTFILES); currentfile++)
        {
            tfclose(opf[currentfile]);
            opf[currentfile] = (FILE *)NULL;
        }
    }
    tfclose(thipf);
    tfclose(tdipf);
    
    return 0;
    
}  /* End of main sth2seg */

/*
 *  Write the File Header record:
 */
/*
 *  Write the FH record to this output file:
 */
void FHwrite (unsigned char *FHrec, int *FHlength, FILE *outfile, char *filename)
{
    int l = 0;
    
    l = fwrite(FHrec, 1, LEN_FH, outfile);
    if (l != LEN_FH)
    {
        fprintf(stderr,
                "ERROR: First File Header record not complete - length %d\n"
                "       errno = %d\n", l, errno);
        fprintf(stderr, "       Error writing file %s\n", filename);
        fprintf(stderr, "       Program terminates.\n");
        exit(BAD_FH_WRITE1);
    }
    *FHlength = *FHlength + LEN_FH; /* Count length of record written */
    return;
}


/*
 * Conditionally close a file, if the pointer is not NULL
 */
int tfclose (FILE *filep)
{
    int ret = 0;
    
    if (filep == (FILE *) NULL)
    {
        return (0);
    }
    else 
    {
        ret = fclose(filep);
        /* NOTE: Do ***NOT*** un-comment the following statement, as the file
         *       being close *might* be stdin or stdout or stderr
         */
//        filep = (FILE *)NULL;
        return ret;
    }
}

/*
 **! Byte swap unsigned short
 */
uint16_t swap_uint16( uint16_t val ) 
{
	return (val << 8) | (val >> 8 );
}


/*
 **! Byte swap short
 */
int16_t swap_int16( int16_t val ) 
{
	return (val << 8) | ((val >> 8) & 0xFF);
}

/*
 **! Byte swap unsigned int
 */
uint32_t swap_uint32( uint32_t val )
{
	val = ((val << 8) & 0xFF00FF00 ) | ((val >> 8) & 0xFF00FF ); 
	return (val << 16) | (val >> 16);
}


/*
 **! Byte swap int
 */
int32_t swap_int32( int32_t val )
{
    val = ((val << 8) & 0xFF00FF00) | ((val >> 8) & 0xFF00FF ); 
    return (val << 16) | ((val >> 16) & 0xFFFF);
}

/*
 ** unswap using char pointers
 */
double swap_double(unsigned long long a) 
{
	
    double d;
    unsigned char *src = (unsigned char *)&a;
    unsigned char *dst = (unsigned char *)&d;
	
    dst[0] = src[7];
    dst[1] = src[6];
    dst[2] = src[5];
    dst[3] = src[4];
    dst[4] = src[3];
    dst[5] = src[2];
    dst[6] = src[1];
    dst[7] = src[0];
	
    return d;
}

uint32_t swap_single(uint32_t a)
{
    uint32_t d;
    uint32_t aa;
    unsigned char *src = (unsigned char *)&aa;
    unsigned char *dst = (unsigned char *)&d;
    aa = a;
    dst[0] = src[3];
    dst[1] = src[2];
    dst[2] = src[1];
    dst[3] = src[0];
    return d;
}

/*******************************************************************************
 *  cnvsth2seg.c		
 *  Copyright (c) 2013 Westheimer Energy Consultants Ltd ALL RIGHTS RESERVED
 ******************************************************************************/

